[
  {
    "content": "Strona 1\nProgramowanie w języku asemblera\nProgramowanie  w  języku  asemblera  niewiele  różni  się  od  programowania  w  językach \nwysokiego  poziomu.  Podstawowa  różnica  polega  na  konieczności  korzystania  ze  znacznie \nuboższego  zestawu  instrukcji.  W językach  asemblera  brak  np.  instrukcji  strukturalnych  bądź \ninstrukcji pozwalających w prosty sposób zapisać obliczanie wyrażenia arytmetycznego. Jednakże \nwszystko co możemy zapisać w językach wysokiego poziomu z pewnością można też zapisać \nużywając instrukcji asemblera. Można także zrobić wiele działań niemożliwych do zapisania \nw językach wysokiego poziomu. Programista piszący w języku asemblera ma pełną kontrolę nad \ntym co się dzieje w trakcie obliczeń w procesorze. Nie jest on także ograniczany przez różne reguły \nobowiązujące w językach wysokiego poziomu. Pełna kontrola i brak ograniczeń oznaczają jednak \ntakże pełną odpowiedzialność za pisany program.\nPisząc  program  w  języku  asemblera  posługujemy  się  niemal  wyłącznie  instrukcjami \nodpowiadającymi rozkazom danego procesora. Dlatego konieczne jest poznanie tych rozkazów, \npodobnie jak zaznajomienie się z architekturą tegoż procesora. Program w języku asemblera tworzą \nrozkazy oraz dane, na których te rozkazy działają. Program składa się z kolejnych linii, w każdej \nlinii może znaleźć się jeden rozkaz lub deklaracja pojedynczej danej. Formalnie składnia linii \nprogramu jest następująca:\n[<etykieta>:] <rozkaz lub pseudorozkaz> [<argument>]\ngdzie:\n<etykieta> – ciąg liter i cyfr będący symboliczną reprezentacją określonego adresu\n<rozkaz lub pseudorozkaz> – symboliczna nazwa jednego z rozkazów procesora\nlub jednego z tzw. pseudorozkazów rezerwacji miejsca w pamięci na dane (RST, \nRPA)\n<argument> – liczba dziesiętna lub jedna z etykiet wprowadzonych na początku linii\nPseudorozkazy RST i  RPA pozwalają  odpowiednio  zarezerwować  miejsce  w  pamięci  na \npojedynczą daną o ustalonej (jako argument) wartości początkowej oraz zarezerwować miejsce \nw pamięci na daną bez wskazywania jej wartości początkowej. Jako rozkaz może pojawić się \nnazwa jednego z dostępnych rozkazów. Przyjmiemy, że w procesorze maszyny W dostępnych jest 8 \nrozkazów wymienionych w poniższej tabeli.\nNazwa\nKod\nDziałanie\nSTP\n000\nZatrzymanie (zakończenie) pracy programu\nDOD\n001\nDodanie do akumulatora zawartości komórki pamięci wskazanej \nprzez argument\nODE\n010\nOdjęcie od akumulatora zawartości komórki pamięci wskazanej \nprzez argument\nPOB\n011\nPobranie do akumulatora zawartości komórki pamięci wskazanej \nprzez argument\nŁAD\n100\nZaładowanie  zawartości  akumulatora  do  komórki  pamięci \nwskazanej przez argument\nStrona 2\nNazwa\nKod\nDziałanie\nSOB\n101\nUstalenie,  że  kolejnym  wykonywanym  rozkazem  będzie  ten, \nktóry znajduje się w komórce pamięci wskazanej przez argument \n(tzw. skok bezwarunkowy)\nSOM\n110\nJeżeli w akumulatorze jest liczba ujemna, jako następny będzie \nwykonywany rozkaz umieszczony w komórce pamięci wskazanej \nprzez argument. Jeżeli w akumulatorze jest liczba nieujemna, jako \nnastępny  zostanie  wykonany  rozkaz  umieszczony  w  pamięci \nbezpośrednio za rozkazem SOM\nSOZ\n111\nSkok pod adres wskazany argumentem wykonywany tylko, gdy \nw akumulatorze  jest  0.  W  przeciwnym  razie  jako  następny \nzostanie wykonany rozkaz umieszczony w pamięci bezpośrednio \nza rozkazem SOZ\nAby napisać program w języku asemblera trzeba najpierw stworzyć algorytm rozwiązujący \nokreślone zadanie, sprecyzować go z wykorzystaniem wyłącznie dostępnych rozkazów i wreszcie \nzapisać go w formie linii programu w języku asemblera. Pisanie tego typów programów zilustruję \nkilkoma przykładami.\nPrzykład 1\nNapisać program obliczający iloczyn dwóch liczb naturalnych  a i  b i umieszczający wynik \nw komórce oznaczonej etykietą c.\nPierwszym krokiem rozwiązania tego zadania jest wymyślenie odpowiedniego algorytmu. By \nznaleźć iloczyn dwóch liczb naturalnych a i b, wystarczy na wstępie założyć, że jest on równy 0 a \nnastępnie  a-krotnie zwiększać jego wartość o  b. Ilustruje to schemat blokowy na poniższym \nrysunku:\nStart\nc = 0\na = 0 ?\nStop\nc = c + b\na = a - 1\nRysunek 1. Schemat blokowy algorytmu\nmnożenia\nPoniżej zamieszczono listing odpowiedniego programu w sytuacji, gdy zmienne a i b są równe\nStrona 3\nodpowiednio 4 i 5. Każdej operacji na schemacie zwykle będzie odpowiadać jedna lub więcej linii \nw tekście programu w języku asemblera. Zauważmy, że nadanie wartości początkowej zmiennej c \nnie jest reprezentowane za pomocą sekwencji rozkazów maszyny W ale zostało zrealizowane dzięki \nużyciu pseudorozkazu RST (linia 14 w kodzie). Testowanie, czy a przyjmuje wartość 0 realizuje \nkod  umieszczony w  liniach  1  i  2.  Jeśli  warunek  jest  spełniony (a =  0),  należy  zakończyć \nwykonywanie pętli, pobrać wynik do akumulatora i zakończyć program (linie 10 i 11).",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "15.\nJeden:\nRST 1\nZwiększenie wartości zmiennej c o wartość b realizowane jest przez rozkazy z linii 3, 4 i 5, zaś \ndekrementacja zmiennej a to linie 6, 7 i 8. Zauważmy, że argumentem rozkazu odejmowania (linia \n7) nie jest liczba 1 (ODE 1) ale etykieta Jeden wskazująca na komórkę pamięci zawierającą jedynkę \n(linia 15). W naszym procesorze stosowany jest tryb adresowania bezpośredniego co oznacza, że \nzapis ODE 1 zostałby zinterpretowany jako chęć odjęcia od akumulatora zawartości komórki pamięci \no adresie 1, tymczasem w tej  komórce pamięci  zostanie  umieszczony rozkaz znajdujący się \nw drugiej  linii  kodu  naszego  programu1.  Wreszcie  w  linii  9  wracamy  na  początek  pętli  do \ntestowania warunku jej zakończenia.\nPodany program można poddać  asemblacji (skompilować) i, po załadowaniu do pamięci \noperacyjnej, wykonać. Po jego wykonaniu w akumulatorze powinna się znaleźć końcowa wartość \nzmiennej oznaczonej etykietą c, czyli w tym przypadku wartość 20.\nOperacje na tablicach\nRozkazy wymienione w tabeli na stronie 1 pozwalają zapisać wiele nawet bardzo złożonych \nprogramów operujących na różnorodnych danych. Jednakże operowanie za ich pomocą na danych \ntworzących  złożone  struktury  nie  jest  prostym  zadaniem.  Wymaga  to  wykonania  dość \nskomplikowanych  przekształceń  wykorzystujących  wiedzę  o  położeniu  i  organizacji  danych \nw pamięci komputera. Problem ten zilustruję przykładem.\nW pamięci komputera znajduje się  n-elementowa tablica. Pierwszy element tej tablicy jest \nzapisany w komórce pamięci oznaczonej etykietą Tablica. Do komórki pamięci oznaczonej etykietą \nSuma należy wpisać sumę wszystkich n elementów tablicy.\nZanim przedstawimy rozwiązanie zadania, wyjaśnijmy jak elementy tablicy są rozmieszczone \nw pamięci. Tablica w pamięci komputera tworzy spójny obszar, każdy kolejny element tablicy \nzapisany jest w kolejnej komórce tego obszaru. Na przykład czteroelementową tablicę wypełnioną\n1\nProgram jest zawsze ładowany do pamięci począwszy od komórki o adresie 0\nStrona 4\nczterema  kolejnymi  liczbami  naturalnymi  zapiszemy  w  języku  asemblera  maszyny  W \nw następujący sposób:",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "RST 4\nZnając adres pierwszego elementu tablicy z łatwością możemy wyznaczyć położenie w pamięci \n(adres) któregokolwiek innego elementu tablicy. Założymy, że tablica, podobnie jak w języku C, \nbędzie indeksowana od 0. Aby wyznaczyć adres w pamięci trzeciego elementu tablicy (czyli \nelementu o indeksie 2), należy do adresu początku tablicy dodać indeks odpowiedniego elementu. \nJeżeli tablica rozpoczyna się od komórki pamięci o adresie 20, to trzeci element tej tablicy \nznajdziemy pod adresem 22 (20 + 2 = 22).\nAby  zsumować  wszystkie  elementy  tablicy  zaczniemy  od  wyzerowania  zmiennej  Suma. \nNastępnie będziemy do zmiennej Suma w pętli dodawać wartości kolejnych elementów poczynając \nod pierwszego z nich, czyli tego, który znajduje się pod adresem symbolicznym reprezentowanym \netykietą Tablica. W każdym kolejnym przebiegu pętli będzie dodawana wartość kolejnego elementu \ntablicy, czyli adres dodawanego elementu za każdym przebiegiem pętli musimy zwiększać o 1. \nTego typu zadanie łatwo byłoby zrealizować posługując się rozkazami używającymi adresowania \npośredniego bądź indeksowego. Wiele procesorów oferuje takie rozkazy.\nNa liście rozkazów naszego komputera nie znajdziemy jednak rozkazów posługujących się \ninnymi trybami adresowania niż adresowanie bezpośrednie. Dlatego też nasze rozwiązanie będzie \nwymagać modyfikacji treści programu w trakcie jego działania.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "20.\nJeden:\nRST 1\nZa każdym przebiegiem pętli trzeba modyfikować treść rozkazu dodawania kolejnego elementu \ntablicy, tak aby rozkaz ten rzeczywiście za każdym razem używał adresu kolejnego elementu. Skoro \nelementy tablicy są zapisane w pamięci po kolei jeden za drugim, oznacza to, że, jak już wcześniej\nStrona 5\npowiedziano, w każdym przebiegu pętli musimy zwiększać adres dodawanego elementu o 1. \nZadanie to realizują rozkazy umieszczone w liniach 8, 9 i 10. Do akumulatora pobierany jest \nz pamięci rozkaz dodawania kolejnego elementu tablicy (linia 6 w programie), zwiększany o 1 \ni ponownie zapisywany w to samo miejsce do pamięci. Dzięki temu, gdy rozkaz ten (z linii 6) \nbędzie ponownie wykonywany, jego argumentem będzie już kolejny element tablicy. Należy tu \nwyraźnie zaznaczyć, że modyfikacja z linii 8 – 10 zmienia wyłącznie treść rozkazu z linii 6 a nie \npowoduje zmiany znaczenia etykiety Tablica. Jeżeli w programie w kilku rozkazach wystąpiłaby \nkonieczność odwoływania się do kolejnych elementów tablicy w kolejnych przebiegach pętli, \nwszystkie te rozkazy należałoby w podobny sposób modyfikować.\nZadanie sumowania elementów tablicy można zrealizować także nieco inaczej.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "24.\nAdres:\nRST Tablica\nI w tym przypadku w pętli dodawane są kolejne elementy tablicy, ale nieco inaczej działa \nmodyfikacja kodu. Rozwiązanie to przypomina rozwiązanie wykorzystujące wskaźniki w języku C. \nKomórka  oznaczona  etykietą  Adres (linia  24)  zawiera  adres  początku  tablicy  (jest  jakby \nwskaźnikiem na tą tablicę). W każdym przebiegu pętli do dotychczasowej sumy dodawana jest \nwartość elementu tablicy wskazywanego przez wskaźnik Adres (linia 9). Aktualna wartość komórki \nAdres dodawana jest do kodu rozkazu POB 0 (linia 23) i wynik zapisywany w miejsce oznaczone \netykietą  Rozkaz (linia 9). W ten sposób uzyskujemy rozkaz dodający do akumulatora zawartość \nodpowiedniej komórki pamięci, tej której adres zawiera komórka Adres.\nOperacje wejścia/wyjścia\nDotychczasowe programy nie wymieniały informacji z otoczeniem a jedynie przetwarzały dane\nStrona 6\nna  wstępie  umieszczone  w  pamięci  i  tam  też  (w  pamięci)  zapisywały wyniki.  Programy te \ndziałałyby znacznie bardziej ogólnie i byłyby bardziej użyteczne, gdyby dane wejściowe można \nbyło wprowadzić z klawiatury a wynik działania programu wyświetlić na ekranie. Aby to jednak \nbyło możliwe, konieczne jest uzupełnienie listy rozkazów o tzw. rozkazy wejścia/wyjścia.\nRozkazy wejścia/wyjścia\nDla zapewnienia wymiany informacji z otoczeniem należy dodać co najmniej 2 rozkazy: rozkaz \nwczytania  pojedynczego  znaku  z  urządzenia  wejściowego  (np.  klawiatury)  oraz  rozkaz \numożliwiający  wyprowadzenie  zawartości  akumulatora  na  urządzenie  wyjściowe  (np.  ekran). \nArgumentami  obydwu  tych  rozkazów  będzie  numer  urządzenia,  którego  dotyczy  rozkaz. \nPrzyjmiemy, że standardowe urządzenie wejściowe (klawiatura) oznaczone jest numerem 1, zaś \nstandardowe  urządzenie  wyjściowe  oznaczone  jest  numerem  2.  Rozkaz  wczytywania  znaku \nnazwiemy WPR (wprowadź znak). Po wczytaniu kod wczytanego znaku zostaje umieszczony \nw akumulatorze.  Rozkaz  wyprowadzania  znaku  (WYP)  wypisze  znak,  którego  kod  jest \nw akumulatorze, na urządzenie wyjściowe o podanym numerze. Wykorzystując te rozkazy można \nna  przykład  napisać  program  kopiujący  na  urządzenie  wyjściowe  znaki  wprowadzone  na \nklawiaturze. Program w pętli wczytuje znak i wypisuje go na standardowe wyjście. Sygnałem do \nzakończenia programu może być wprowadzenie jakiegoś umówionego znaku kończącego. U nas \ntakim znakiem będzie spacja. Poniżej znajduje się kod tego programu.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "8.\nSpacja:\nRST 32\nZwykle programy obliczeniowe jako danych wejściowych nie potrzebują pojedynczych znaków \nale liczb zapisanych w postaci ciągu cyfr. Także wyniki liczbowe należałoby wyświetlać jako ciągi \ncyfr dziesiętnych. Oznacza to konieczność konwersji wczytanych ciągów cyfr do postaci liczby \noraz  oraz  odwrotnej  zamiany  liczby  zapisanej  binarnie  na  odpowiednią  sekwencję  cyfr \ndziesiętnych. Wydaje się, że najlepiej będzie, jeśli zadania te zostaną zrealizowane w postaci \nspecjalnych podprogramów.\nPodprogramy\nKorzystanie z podprogramów  oznacza konieczność dodania kolejnych kilku rozkazów  do \nnaszego procesora. Rozkaz skoku do podprogramu SDP podobnie do zwykłego skoku powoduje \nprzejście do wykonywania rozkazu, którego adres jest argumentem rozkazu SDP. Dodatkowo \njednak na stosie zapisywana jest zawartość licznika rozkazów (tzw. ślad). Dzięki zachowaniu śladu \nna stosie możliwy jest powrót do wykonywania następnego rozkazu po rozkazie SDP w momencie, \ngdy  zakończono  wykonywanie  podprogramu.  Powrót  ten  realizuje  rozkaz  PWR.  Ponadto \nwprowadzimy jeszcze 2 rozkazy związane ze stosem: DNS – dopisujący zawartość akumulatora na \nszczyt stosu oraz PZS zdejmujący wartość ze szczytu stosu i zapisujący ją w akumulatorze. \nRozkazy te często są używane do przekazywania parametrów między programem wywołującym \na podprogramem. Poniżej przedstawiono podprogram obliczający kwadrat danej liczby. Liczba, \nktórej kwadrat chcemy znaleźć powinna najpierw zostać umieszczona w akumulatorze. Także w\nStrona 7\nakumulatorze podprogram zwróci wynik.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "STP\n// po wykonaniu podprogramu wynik w akumulatorze, ko czymy program \nń\n3.\nkwadrat: ŁAD liczba\n// tu zaczyna si  podprogram, parametr zachowany w zmiennej liczba\nę",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "SOZ zero\n// gdy zero, nic nie trzeba liczy  (wynikiem te  jest zero), wracamy\nć\nż\n6.\ndodatnia: ŁAD iloczyn\n// nie ujemna i nie zero, wi c dodatnia; pierwszy przebieg p tli\nę\nę\n7.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "ŁAD liczba\n// potrzebne, gdy była liczba ujemna i obliczono jej warto\n bezwzgl dn\nść\nę ą\n8.\np tla:  \nę\nODE jeden\n// w ka dym przebiegu p tli dekrementujemy licznik wykona\nż\nę\nń",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "15.\nSOB p tla\nę\n16.\nwracaj: POB iloczyn\n// na koniec wynik w zmiennej iloczyn a powinien znale\n si  w akumulatorze\nźć ę\n17.\nzero:   \nPWR\n// i wracamy do programu głównego\n18.\nujemna: ODE liczba\n// parametrem liczba ujemna, a zatem obliczamy najpierw jej wartość",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "SOB dodatnia\n// jak z liczb  dodatni   (-a) \ną\ną\n2 = a 2\n21.\nliczba:\nRPA\n//  warto\n parametru podprogramu\nść\n22.\niloczyn: RPA\n// wynik obliczania kwadratu liczby\n23.\nlicznik: RPA\n// licznik przej\n p tli (inicjowany identycznie jak liczba)\nść ę\n24.\njeden:  \nRST 1 \nProgram  główny (linie  1  i  2)  został  tu  uproszczony  do  maksimum  i  sprowadza  się  do \nwywołania  podprogramu  obliczającego  kwadrat  liczby  zapisanej  w  akumulatorze2.  Treść \npodprogramu rozpoczyna się w linii 3. Parametr (liczba, której kwadrat chcemy policzyć) znajduje \nsię w akumulatorze. Najpierw podprogram sprawdza z jaką wartością parametru ma do czynienia. \nJeżeli jest to zero, natychmiast przechodzimy do rozkazu powrotu z podprogramu a zwracanym \nwynikiem jest 0. Gdy w akumulatorze znajduje się liczba ujemna, obliczana jest liczba do niej \nprzeciwna (lub jeśli ktoś tak woli wartość bezwzględna) a następnie postępuje się identycznie jak \ndla liczby dodatniej. W przypadku liczby dodatniej, by wyznaczyć jej kwadrat wystarczy liczbę tę \ndodać do siebie określoną liczbę razy. Zadanie to realizuje pętla, której treść zapisano w liniach od \n8 do 15.\nPodprogram wypisywania liczby całkowitej na urządzenie wyjściowe\nZadanie wypisywania liczby umieszczonej w akumulatorze na urządzenie wyjściowe można \nzrealizować w postaci podprogramu Write o kodzie przedstawionym poniżej.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3.\nWrite:  ŁAD liczba\n2\nW celu przetestowania programu należy przed jego uruchomieniem do akumulatora wpisać liczbę całkowitą, której \nkwadrat chcemy obliczyć\nStrona 8",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "36.\nMinus:  RST '-'\nLista  rozkazów  została  wzbogacona  o  rozkazy  mnożenia  (MNO)  i  dzielenia  (DZI). \nPodstawowym zadaniem tej procedury jest przekształcenie liczby binarnej do postaci ciągu cyfr \ndziesiętnych  (reprezentowanych  jako  znaki  ASCII).  Konwersja  ta  została  zrealizowana \nz wykorzystaniem stosu. Na stos ładowane są po kolei cyfry (zapisane z użycie kodu ASCII) będące \nkolejnymi resztami z dzielenia liczby binarnej przez 10. Do każdej reszty dodawany jest kod ASCII \nodpowiadający znakowi 0, dzięki czemu od razu dokonywana jest konwersja na znaki tego kodu. \nCyfry tworzące zapis liczby generowane są zatem od końca, dzięki zastosowaniu stosu będą jednak \nwyprowadzane na wyjście w odwrotnej, czyli poprawnej, kolejności. W kolejnym kroku liczba \nzostaje podzielona przez 10 i czynności są powtarzane aż do osiągnięcia wartości 0. Wtedy ze stosu \npobieramy po kolei cyfry i wypisujemy na urządzenie wyjściowe. Aby łatwo wykryć kiedy kończą \nsię cyfry, zanim zapisywano je na stosie umieszczono tam tzw. wartownika (tu w postaci liczby 0,\nStrona 9\nzob. linie 4 i 5 w kodzie podprogramu). Pobranie ze stosu wartownika powoduje zakończenie \nwypisywania cyfr na wyjście i tym samym oznacza zakończenie podprogramu.\nTakże  podczas  wczytywania  liczby  dokonywana  jest  konwersja  kolejnych  tworzących  ją \nznaków na odpowiednią postać binarną. Zadanie to realizuje procedura Read. Czyta ona kolejne \ncyfry tworzące zapis liczby naturalnej i konwertuje na postać binarną aż do natrafienia na znak inny \nniż cyfra. Po wykonaniu wczytana liczba znajduje się w akumulatorze. Kod wczytywania liczby \npozostawiamy czytelnikowi do analizy.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Napisać program obliczający największy wspólny dzielnik NWD dwu liczb naturalnych\numieszczonych w komórkach oznaczonych etykietami A i B.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Napisać  program  obliczający  najmniejszą  wspólną  wielokrotność  NWW  dwu  liczb\nnaturalnych umieszczonych w komórkach oznaczonych etykietami A i B.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. Napisać program obliczający iloczyn dwu liczb naturalnych umieszczonych w komórkach\noznaczonych etykietami A i B.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. Napisać  program obliczający resztę  z  dzielenia  dwu  liczb  naturalnych  umieszczonych\nw komórkach oznaczonych etykietami A i B.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "5. Dana jest n-elementowa tablica oznaczona etykietą Tab. Napisać program sprawdzający ile\nrazy w tej tablicy pojawia się bajt o wartości podanej w komórce Wzorzec.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. Dana jest  n-elementowa tablica oznaczona etykietą  Tab. Napisać program zamieniający\nparami elementy tej tablicy. Założyć, że  n jest liczbą parzystą. Np. jeśli w tablicy były \nkolejno liczby 1 2 3 i 4, to po wykonaniu programu ma być 2 1 4 3.\nStrona 10",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "7. Dana jest  n-elementowa tablica oznaczona etykietą  Tab. Napisać program odwracający\nzawartość tej tablicy. Np. jeśli w tablicy były kolejno liczby 1 2 3 4 i 5, to po wykonaniu \nprogramu ma być 5 4 3 2 1.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "8. Dana  jest  n-elementowa  tablica  oznaczona  etykietą  Tab.  Napisać  program  znajdujący\nwartość największego elementu tej tablicy i wpisujący ją do komórki Max.",
    "source": "Asembler.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "MINUT 2020 (2), s. 1\u001511\nAlina MOMOT\nWydziaª Automatyki, Elektroniki i Informatyki, Politechnika l¡ska,\nul. Akademicka 16, 44-100 Gliwice\nProjektowanie rozkazów dla maszyny W \u0015 konspekt ¢wicze«\nlaboratoryjnych\nStreszczenie. Artykuª opisuje propozycj¦ przeprowadzenia ¢wicze« laboratoryjnych dotycz¡-\ncych podstaw projektowania rozkazów dla maszyny W. Zakªada si¦ przy tym, »e uczestnicy la-\nboratorium dysponuj¡ programowym symulatorem maszyny W oraz przyswoili ju» podstawowe\nwiadomo±ci na temat architektury tej maszyny, sposobu dziaªania ukªadu steruj¡cego i ogólnych\nzasad projektowania rozkazów.\nSªowa kluczowe: maszyna W, projektowanie rozkazów, konspekt zaj¦¢.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Wst¦p\nSkutecznie przeprowadzone zaj¦cia lekcyjne powinny obejmowa¢ przede wszystkim prezentacj¦ zro-\nzumienia materiaªu przez ucznia. Wymaga to od uczniów kierowania si¦ celem uczenia si¦ i pogª¦biania\nrozumienia omawianego materiaªu. Prezentacja taka stanowi dowód zrozumienia tre±ci i nabycia umiej¦t-\nno±ci zawartych w celu uczenia si¦ [5]. Dlatego te» bardzo wa»ne jest, aby zarówno ucze«, jak i nauczyciel\nznali ten cel i zmierzali w jego kierunku. Równie wa»ne jest okre±lenie i przygotowanie odpowiednich\nkryteriów sukcesu oraz odpowiednie zwi¦kszanie stopnia trudno±ci realizowanych zada« w zale»no±ci od\nmo»liwo±ci danego ucznia. Jak pisz¡ autorki ksi¡»ki Cele uczenia si¦. Jak pomóc uczniom zrozumie¢ ka»d¡\nlekcj¦ (zob. [5], s. 76): \u0012Bardzo wa»ne jest tutaj rozró»nienie celu uczenia si¦ i oceny. Nie chodzi nam o to,\n»e oceny nie s¡ wa»ne. Uwa»amy jednak, »e kiedy nauczyciele zach¦caj¡ uczniów do uczenia si¦ na kon-\nkretny stopie«, a nie do opanowania materiaªu, który spowoduje wystawienie takiego stopnia, ograniczaj¡\nmo»liwo±ci swoich uczniów\u0011.\nZach¦canie uczniów do samodzielno±ci jest kluczowym elementem procesu uczenia si¦. Potrzeb¦ samo-\ndzielno±ci w zdobywaniu wiedzy zauwa»ano ju» w ubiegªym wieku. Jak pisze bowiem w wydanej w 1938\nroku ksi¡»ce Ignacy Schreiber (zob. [7], s. 8\u00159): \u0012ucze« naprawd¦ musi wprawi¢ si¦ w samodzielne zdo-\nbywanie wiedzy i nauczy¢ si¦ samodzielnie osi¡gni¦tymi ju» wiadomo±ciami operowa¢. W przeciwnym\nbowiem wypadku przyjmuje gotow¡ potraw¦ ju» pokrajan¡ i przygotowan¡ ostatecznie do spo»ycia, ale\nmo»e j¡ tylko poªkn¡¢ i w miar¦ nabywanej wprawy coraz to lepiej poªyka, nie mo»e jej jednak strawi¢;\nAutor korespondencyjny: A. Momot (alina.momot@polsl.pl).\nData wpªyni¦cia: 12.01.2020.\n2\nA. Momot\ni nigdy nie nauczy si¦ samodzielnie swych potraw przyrz¡dza¢\u0011. W ksi¡»ce tej autor zwraca równie» uwa-\ng¦ na problem przywi¡zywania przez uczniów nadmiernej wagi do otrzymywanych ocen (zob. [7], s. 96):\n\u0012Ucze« widzi w nauce nie warto±ci istotne a tylko mo»liwo±¢ uzyskania tych czy innych stopni, za którymi\nidzie patent. Ten ±wistek papieru, któremu ustawa nadaªa moc prawn¡, jest wytyczn¡ jego dziaªania.\nZ nielicznymi wyj¡tkami dziecko nie chce posi¡±¢ wiedzy [...]. W zasadzie uczniowi chodzi o dodatni\nstopie« i za niego, pobawmy si¦ w paradoks, gotów zrzec si¦ caªej wiedzy\u0011. Autor stawia dalej tez¦, »e\nw zwi¡zku z tym jako jeden z najwa»niejszych ±rodków nauki ucze« widzi ±ci¡ganie, za±: \u0012To absurdalne\nstanowisko jest naturalnym wynikiem uto»samienia nauki z ocen¡, uzale»nieniem warto±ci intelektualnych\nod praktycznych celów\u0011. Dodaje te», »e: \u0012Mo»na zapatrywanie to zwalcza¢, je»eli kto± lubi donkiszoteri¦\ni walk¦ z wiatrakami, ale jest ono racjonalne z punktu widzenia dzieci, a ojcami jego jeste±my my sami,\npedagogowie, którzy oddzielili±my si¦ od dusz dzieci¦cych murem naszego systemu not i kar\u0011 (zob. [7],\ns. 96).\nBior¡c pod uwag¦ powy»sze rozwa»ania, mo»na stwierdzi¢ zatem, »e w procesie skutecznego uczenia\nkluczowe jest tzw. ocenianie ksztaªtuj¡ce (ang. formative assessment). Termin ten wprowadziª do eduka-\ncji w latach 70. ubiegªego stulecia Benjamin Samuel Bloom [1], wskazuj¡c jako gªówn¡ cech¦ oceniania\nksztaªtuj¡cego informacj¦ zwrotn¡, która ma pomóc uczniowi si¦ uczy¢ oraz umo»liwi¢ nauczycielowi\ndoskonalenie techniki nauczania. Pod koniec lat 90. ubiegªego wieku Brytyjskie Stowarzyszenie Bada«\nEdukacyjnych powoªaªo specjalny zespóª pracuj¡cy nad szkolnym ocenianiem, za± po roku 2000 ocenia-\nnie ksztaªtuj¡ce staªo si¦ wa»nym przedmiotem bada« naukowych. Prof. John Hatti z Nowej Zelandii,\npodsumowuj¡c w 2009 roku wyniki 1287 bada« edukacyjnych, stwierdziª, i» wpªyw informacji zwrotnej\nprzekazywanej uczniowi jest silniejszy ni» inne mo»liwe do zastosowania sposoby oddziaªywania nauczy-\nciela na ucznia [3].\nW ksi¡»ce Ucz¦ (si¦) w szkole Danuta Sterna stwierdza (zob. [8], s. 17): \u0012w ocenianiu ksztaªtuj¡cym\nstaramy si¦, aby uczniowie byli gotowi wzi¡¢ odpowiedzialno±¢ za swój proces uczenia si¦, aby bardziej za-\nle»aªo im na wiedzy ni» na wynikach testów, które t¦ wiedz¦ sprawdzaj¡\u0011. Opisuje ona pi¦¢ podstawowych\nstrategii oceniania ksztaªtuj¡cego, które mo»na stre±ci¢ w poni»szych punktach (zob. [8], s. 18\u001519):\n1) \u0012Okre±lanie i wyja±nianie uczniom celów uczenia si¦ i kryteriów sukcesu.\nZ perspektywy ucznia: Lepiej si¦ ucz¦, je±li wiem po co i czego mam si¦ nauczy¢.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2) Organizowanie\nw\nklasie\ndyskusji,\nzadawanie\npyta«\ni\nzada«\ndaj¡cych\ninformacje,\nczy i jak uczniowie si¦ ucz¡.\nZ perspektywy ucznia: Lepiej si¦ ucz¦, je±li nauczyciel rozmawia ze mn¡ o moich post¦pach i w ka»dej\nchwili wie, na jakim etapie nauki jestem.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3) Udzielanie uczniom takich informacji zwrotnych, które umo»liwiaj¡ im widoczny post¦p.\nZ perspektywy ucznia: Lepiej si¦ ucz¦, je±li nauczyciel udziela mi informacji zwrotnej, co zrobiªem\ndobrze, co i jak powinienem poprawi¢ i jak mog¦ si¦ dalej rozwija¢.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4) Umo»liwianie uczniom korzystania z siebie nawzajem jako zasobów edukacyjnych.\nZ perspektywy ucznia: Lepiej si¦ ucz¦, je±li korzystam z wiedzy i umiej¦tno±ci moich kole»anek i ko-\nlegów.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "5) Wspomaganie\nuczniów,\nby\nstali\nsi¦\nodpowiedzialnymi\nautorami\nprocesu\nswojego\nuczenia si¦.\nZ perspektywy ucznia: Lepiej si¦ ucz¦, gdy jestem ±wiadomy, jak przebiega proces mojego uczenia si¦\ni odpowiadam za niego\u0011.\nProjektowanie rozkazów dla maszyny W \u0015 konspekt ¢wicze« laboratoryjnych\n3\nOpisan¡ wy»ej koncepcj¦ oceniania ksztaªtuj¡cego mo»na z powodzeniem stosowa¢ w procesie ksztaª-\ncenia studentów wy»szych uczelni podczas zaj¦¢ laboratoryjnych. W odró»nieniu od wykªadów, gdzie\ngªównym celem jest jedynie przekazywanie okre±lonych tre±ci, zaj¦cia laboratoryjne umo»liwiaj¡ bardziej\nindywidualne podej±cie do studenta, poniewa» prowadzone s¡ w maªych grupach. W trakcie tego ty-\npu zaj¦¢ prowadz¡cy ma mo»liwo±¢ bezpo±redniej wery\u001ckacji posiadanych przez studenta umiej¦tno±ci.\nZakªada si¦ przy tym, »e student nie tylko ma rozwi¡zywa¢ kolejno stawiane przed nim zadania, ale\nnale»y wymaga¢ od niego równie» dokonywania jasnej prezentacji tych rozwi¡za«, co b¦dzie stanowi¢\ndowód zrozumienia materiaªu. Poprzez wskazywanie niedoci¡gni¦¢ oraz porównanie oceny zaprezentowa-\nnego rozwi¡zania przez innych, student ma mo»liwo±¢ rozwijania swoich umiej¦tno±ci praktycznych jak\nrównie» samodzielnej oceny swoich dokona«.\nNa Wydziale Automatyki, Elektroniki i Informatyki Politechniki l¡skiej dla studentów kierunku\ninformatyka od lat prowadzone s¡ zaj¦cia z przedmiotu podstawy informatyki. W ramach tych zaj¦¢ pro-\nwadzone s¡ wykªady, ¢wiczenia tablicowe oraz ¢wiczenia laboratoryjne. Podczas zaj¦¢ laboratoryjnych\nstudenci zapoznaj¡ si¦ mi¦dzy innymi z zagadnieniami dotycz¡cymi budowy i dziaªania komputerów\no architekturze von Neumanna na bardzo prostym przykªadzie maszyny W \u0015 komputera wykªadowego\nzaprojektowanego w latach siedemdziesi¡tych ubiegªego wieku przez prof. Stefana W¦grzyna [9]. Pocz¡t-\nkowo studenci poznawali zasady dziaªania komputera przy u»yciu \u001czycznej implementacji projektu [2],\nobecnie za± do tego celu wykorzystywany jest programowy symulator maszyny W.\nNiniejszy artykuª jest prób¡ pokazania, jak mog¡ wygl¡da¢ przykªadowe zaj¦cia laboratoryjne. Pod-\nczas tych zaj¦¢ studenci b¦d¡ rozwi¡zywa¢ kolejne zadania, poznaj¡c podstawy dziaªania maszyny W\nw praktyce: rozpoczynaj¡c od u±wiadomienia sobie przeznaczenia i roli poszczególnych rejestrów oraz\nukªadu steruj¡cego, poprzez projektowanie przesyªów mi¦dzyrejestrowych i rozkazów dla procesora, a»\npo u»ycie uprzednio zaprojektowanych rozkazów w krótkim programie testuj¡cym poprawno±¢ ich dziaªa-\nnia. Zakªada si¦ przy tym, »e zaj¦cia te realizowane s¡ w ramach jednego spotkania trwaj¡cego 3 godziny\nzegarowe (czyli 4 godziny lekcyjne, jak ma to miejsce obecnie).\nPrzy tworzeniu zaprezentowanego ni»ej konspektu wykorzystywano sugestie zawarte w ksi¡»ce Tech-\nnologie informacyjno-komunikacyjne na lekcjach. Przykªadowe konspekty i polecane praktyki [6]. Autorki\nprzedstawiaj¡ tam wskazówki jak tworzy¢ konspekty lekcji z zastosowaniem oceniania ksztaªtuj¡cego,\nsugeruj¡ stawianie polece« pobudzaj¡cych gª¦bokie my±lenie uczniów oraz zadawanie pyta« otwartych,\ndaj¡c przy tym uczniom czas na ustalenia odpowiedzi. Podkre±laj¡ przy tym, i» nale»y wykorzystywa¢\nw procesie uczenia bª¦dne odpowiedzi uczniów i zwracaj¡ uwag¦ na fakt, »e informacja zwrotna wi¡»e\nsi¦ z kryteriami sukcesu (zob. [6], s. 24): \u0012okre±la, co jest dobre, co wymaga poprawy, w jaki sposób t¦\npopraw¦ wykona¢ i jak post¦powa¢ dalej\u0011, a podstaw¡ uczenia si¦ jest szukanie i eliminowanie bª¦dów.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Konspekt ¢wicze« laboratoryjnych\nZanim przejdziemy do opisu planowanego przebiegu zaj¦¢, warto okre±li¢ formalnie kilka podstawo-\nwych faktów.\n• Temat: Projektowanie rozkazów dla maszyny W.\n• Cel: praktyczne poznanie zasad dziaªania ukªadu steruj¡cego komputera w architekturze von Neu-\nmanna.\n• Kryteria sukcesu dla studenta:\n4\nA. Momot\n\u0015 umiem opisa¢ i scharakteryzowa¢ najwa»niejsze elementy skªadowe komputera w architekturze\nvon Neumanna,\n\u0015 rozumiem zapisy przesyªów mi¦dzyrejestrowych w notacji nawiasowej,\n\u0015 umiem zaprojektowa¢ przesyª mi¦dzyrejestrowy dla maszyny W,\n\u0015 umiem sprawdzi¢ dziaªanie napisanego przesyªu w symulatorze maszyny W,\n\u0015 rozró»niam poj¦cie przesyªu mi¦dzyrejestrowego od rozkazu procesora,\n\u0015 umiem zaprojektowa¢ nowy rozkaz dla maszyny W,\n\u0015 umiem przetestowa¢ dziaªanie napisanego rozkazu w symulatorze maszyny W.\n• Dotychczasowa wiedza i umiej¦tno±ci uczniów:\nzakªada si¦, »e student poznaª na wykªadzie z przedmiotu podstawy informatyki podstawowe\nelementy konstrukcyjne komputera, takie jak: rejestry, liczniki, jednostka arytmetyczno\u0015logiczna,\nukªad pami¦ci, ukªad steruj¡cy; umie wyja±ni¢ ró»nice mi¦dzy poziomowymi i impulsowymi sygna-\nªami steruj¡cymi; zna poj¦cia cyklu zegarowego (taktu) oraz cyklu instrukcji; potra\u001c opisa¢ schemat\nbudowy i zasady dziaªania komputera w architekturze von Neumanna na przykªadzie maszyny W;\nzna standardow¡ list¦ rozkazów maszyny W.\nPonadto zakªada si¦, »e podczas ¢wicze« tablicowych student zapoznaª si¦ z notacj¡ nawiasow¡ sªu-\n»¡c¡ do opisu przesyªów mi¦dzyrejestrowych oraz potra\u001c teoretycznie zaprojektowa¢ proste przesyªy\ni rozkazy dla maszyny W [4].\n• Wykorzystywane narz¦dzia TIK1 oraz cel ich zastosowania:\npodczas zaj¦¢ studenci korzysta¢ b¦d¡ z programowego symulatora maszyny W2, aby lepiej zrozu-\nmie¢ dziaªanie komputera, maj¡c mo»liwo±¢ bezpo±redniego ±ledzenia zmian zawarto±ci poszczegól-\nnych rejestrów oraz pami¦ci operacyjnej w zale»no±ci od aktywowanego sygnaªu steruj¡cego.\nPoni»ej przedstawiony zostanie przykªadowy przebieg zaj¦¢ laboratoryjnych. Ze wzgl¦du na przejrzy-\nsto±¢ zastosowano tu podziaª na trzy etapy. Najpierw studenci podczas dyskusji z prowadz¡cym powinni\nprzypomnie¢ sobie, jak zbudowana jest maszyna W i jakie s¡ konsekwencje zastosowania architektury\nvon Neumanna. Nast¦pnie studenci, pracuj¡c samodzielnie lub w parach, realizuj¡ pierwsze zadania \u0015\nprojektuj¡ przesyªy mi¦dzyrejestrowe przy nieaktywnym ukªadzie steruj¡cym jednostki centralnej. Na\nostatnim etapie studenci projektuj¡ rozkazy, zapisuj¡ je w odpowiedniej dla symulatora maszyny W no-\ntacji, a nast¦pnie testuj¡ ich dziaªanie, pisz¡c krótkie programy z u»yciem utworzonych rozkazów. Ka»dy\nz tych etapów jest opisany w oddzielnym podrozdziale.\n2.1. Wprowadzenie \u0015 przypomnienie charakterystyki maszyny W\nNa pocz¡tku zaj¦¢ prowadz¡cy prosi studentów o uruchomienie symulatora maszyny W (rys. 1),\nnast¦pnie pyta studentów o poszczególne elementy skªadowe jednostki centralnej.\n• Do czego sªu»y rejestr I (instrukcji)?\nDlaczego jest on podzielony na dwie cz¦±ci?\nDlaczego ma on wej±cie od strony magistrali danych?\nDlaczego ma on wyj±cie na magistral¦ adresow¡?\n1 Skrót TIK jest u»ywany dla opisu technologii informacyjno-komunikacyjnych.\n2 Jest on dost¦pny na Platformie Zdalnej Edukacji Politechniki l¡skiej dla studentów zapisanych na kurs Podstawy\nInformatyki.\nProjektowanie rozkazów dla maszyny W \u0015 konspekt ¢wicze« laboratoryjnych\n5\n• Do czego sªu»y rejestr L (licznika)?\nDlaczego jest on podpi¦ty tylko do magistrali adresowej?\nDlaczego ma on sygnaª il (inkrementuj¡cy jego zawarto±¢)?\n• Jak dziaªa JAL (jednostka arytmetyczno\u0015logiczna)?\nDlaczego sygnaª wej±ciowy (weja) jest sygnaªem poziomowym?\nDo czego sªu»y rejestr Ak (akumulator)?\nJakie s¡ konsekwencje uaktywnienia sygnaªów przep, dod lub ode?\n• Jak dziaªa PaO (pami¦¢ operacyjna)?\nDo czego sªu»y rejestr A (adresowy), a do czego S (sªowa)?\nDlaczego nie ma mo»liwo±ci wyprowadzenia zawarto±ci rejestru A (nie ma sygnaªu wya)?\nJakie s¡ konsekwencje uaktywnienia sygnaªów czyt lub pisz?\nCzy s¡ to sygnaªy poziomowe czy impulsowe?\nRysunek 1. Widok okna symulatora podstawowej wersji maszyny W\nW dalszej cz¦±ci studenci poproszeni zostaj¡ o odª¡czenie ukªadu steruj¡cego maszyny W (zaznaczenie\nopcji sterowanie r¦czne w widoku jednostki centralnej) oraz o samodzielne wprowadzenie przykªadowej,\nniezerowej warto±ci do rejestru L (za pomoc¡ lewego przycisku myszy w obszarze prostok¡ta wizualizu-\nj¡cego ten rejestr w widoku jednostki centralnej). Nast¦pnie prowadz¡cy pyta, jakie sygnaªy steruj¡ce\nnale»y uaktywni¢, aby zrealizowa¢ przesyª (L) →A (przesªanie zawarto±ci rejestru licznika do rejestru\nadresowego pami¦ci operacyjnej). Po wybraniu odpowiednich sygnaªów (wyl, wea) poprzez wskazanie ich\n6\nA. Momot\nlewym przyciskiem myszy, studenci realizuj¡ wykonanie taktu (cyklu zegarowego), wybieraj¡c odpowied-\nni¡ opcj¦ z menu wykonaj lub przy u»yciu przycisku F7. Warto przy tym zwróci¢ uwag¦, »e oba sygnaªy\n(wyl, wea) musz¡ by¢ aktywne równocze±nie w tym samym takcie, gdy» aktywacja tylko jednego sygnaªu\nsteruj¡cego w pojedynczym takcie spowoduje powstanie bª¦du. Gdyby±my chcieli w jednym takcie akty-\nwowa¢ jedynie sygnaª wyl, a w kolejnym sygnaª wea, przy próbie wprowadzenia warto±ci do rejestru A\nsymulator maszyny W zgªosi komunikat o bª¦dzie: Magistrala A jest pusta.\nW tym momencie warto przypomnie¢ studentom i zwróci¢ uwag¦ na konsekwencje stosowania pozio-\nmowych i impulsowych sygnaªów steruj¡cych. Sygnaª wyl jest poziomowy, czyli jest aktywny przez caªy\nczas trwania cyklu zegarowego (taktu) i jest u»ywany przy wyprowadzaniu zawarto±ci rejestru na magi-\nstral¦. Natomiast sygnaª wea jest impulsowy, czyli jest aktywowany na ko«cu cyklu zegarowego (taktu)\ni sªu»y do wprowadzania warto±ci z magistrali do rejestru.\nNast¦pnie prowadz¡cy zadaje studentom pytanie, co spowoduje równoczesna aktywacja sygnaªów\nwyl, wea, il (sygnaªy aktywujemy w tym samym cyklu zegarowym), a po chwili studenci proszeni s¡\no sprawdzenie swojej odpowiedzi przy u»yciu symulatora maszyny W. Warto równie» przypomnie¢, co\nsi¦ stanie, gdy do aktywnych w jednym takcie sygnaªów wyl, wea, il doª¡czymy dodatkowo sygnaª czyt.\nAby lepiej zobrazowa¢ t¦ sytuacj¦, prowadz¡cy mo»e poprosi¢ studentów o wypeªnienie kilku kolejnych\nkomórek pami¦ci operacyjnej ró»nymi warto±ciami i ±ledzenie zawarto±ci rejestrów L, A oraz S podczas\nkilkukrotnego wykonywania taktu (F7).\nPrzeprowadzone eksperymenty prowadz¡cy mo»e podsumowa¢ uwag¡, aby optymalizacj¦ czasow¡ re-\nalizacji przesyªów mi¦dzyrejestrowych dokonywa¢ z odpowiednim wyczuciem i trosk¡ o poprawne wyko-\nnanie zadania, za ka»dym razem porównuj¡c otrzymane w symulatorze maszyny W wyniki z warto±ciami\nprzewidywanymi. Nale»y przy tym uwa»nie czyta¢ zgªaszane przez symulator komunikaty. Jako przykªad\nprowadz¡cy mo»e wskaza¢ prób¦ jednoczesnej aktywacji sygnaªów wyl, wyad (próba wysªania na magi-\nstral¦ adresow¡ dwóch warto±ci: z rejestru licznika i z rejestru instrukcji). Wykonanie taktu w tej sytuacji\nposkutkuje komunikatem o bª¦dzie: Magistrala A jest ju» zaj¦ta.\nNast¦pnie warto przypomnie¢ stosowane w maszynie W kodowanie liczb ujemnych w postaci zapisu\nuzupeªnieniowego do 2. Zastosowanie tego kodowania w architekturze 8-bitowej pozwala na zapisanie liczb\nz zakresu od −128 do 127. Zauwa»amy, »e warto±¢ 127 po zinkrementowaniu zmieni si¦ na −128. Prowa-\ndz¡cy mo»e poprosi¢ studentów o wprowadzenie do rejestru Ak (akumulatora) warto±ci np. 250 i zapyta¢\nich jaka jest to liczba: dodatnia czy ujemna. Prowadz¡cy zwraca uwag¦, »e wskazuj¡c prawym przyciskiem\nmyszy dowolny rejestr w symulatorze maszyny W, mo»na zmieni¢ domy±lny tryb wy±wietlania warto±ci\n(u»ywaj¡c opcji Poka» jako mo»emy wybra¢ spo±ród: dziesi¦tnie bez znaku, dziesi¦tnie ze znakiem, bi-\nnarnie, szesnastkowo). Wybieraj¡c binarny tryb wy±wietlania warto±ci, widzimy, »e w przypadku liczb\n8-bitowych dla warto±ci 250 pierwszy od lewej bit (bit znaku) jest równy jeden. Zatem wprowadzona do\nakumulatora warto±¢ jest ujemna (w architekturze 8-bitowej).\nNa koniec pierwszej cz¦±ci zaj¦¢ prowadz¡cy prosi studentów o realizacj¦ przesyªu (Ak) →L, czyli\no przesªanie zawarto±ci rejestru Ak (warto±ci 250) do rejestru L. Dla domy±lnej, standardowej architektury\nmaszyny W (z uwagi na fakt, »e wyj±cie Ak jest podpi¦te do magistrali danych, za± wej±cie L do magistrali\nadresowej) jedynym mo»liwym rozwi¡zaniem jest przesyª za po±rednictwem rejestru instrukcji. Zatem\nw jednym takcie nale»y uaktywni¢ sygnaªy wyak, wei, w nast¦pnym za± wyad, wel. Warto przy tym\nzwróci¢ uwag¦, jaka warto±¢ pojawi si¦ docelowo w rejestrze L. W rejestrze tym powinna pojawi¢ si¦\nwarto±¢ 26 (binarnie 11010), gdy» sygnaª wyad umo»liwia wyprowadzenie na magistral¦ adresow¡ jedynie\n5 bitów z 8-bitowego sªowa (3 najstarsze bity sªowa zostaj¡ \u0012obci¦te\u0011).\nProjektowanie rozkazów dla maszyny W \u0015 konspekt ¢wicze« laboratoryjnych\n7\nW tym momencie prowadz¡cy przypomina studentom o mo»liwo±ci rozszerzenia architektury ma-\nszyny W o poª¡czenie mi¦dzymagistralowe (menu Projekt →Opcje.. →Skladniki →W+), prosi\no jednoczesn¡ aktywacj¦ sygnaªów wyak, sa, wel i wykonanie taktu (F7), po czy zadaje pytanie, co si¦\nstaªo i dlaczego. Zawarto±¢ rejestru licznika nie zmieniªa si¦, gdy» w standardowej 8-bitowej architek-\nturze maszyny W magistrala adresowa jest w¦»sza od magistrali danych i mo»na ni¡ przesyªa¢ jedynie\n5-bitowe warto±ci. Zatem nawet przy wykorzystaniu poª¡czenia mi¦dzymagistralowego maszyny W+ nie\njest mo»liwe przesªanie 8 bitów sªowa z 8-bitowej magistrali danych na 5-bitow¡ magistral¦ adresow¡.\n2.2. Projektowanie przesyªów mi¦dzyrejestrowych\nDrug¡ cz¦±¢ zaj¦¢ stanowi praca wªasna studentów realizuj¡cych podane przez prowadz¡cego przy-\nkªadowe przesyªy mi¦dzyrejestrowe. Ka»demu ze studentów prowadz¡cy zadaje do zaprojektowania dwa\nprzesyªy. Jeden z nich jest prostym, kilkutaktowym przesyªem, mo»liwym do wykonania w architekturze\nmaszyny W. Drugi z nich jest bardziej skomplikowany i wymaga rozszerzonej architektury W+.\nKilka przykªadowych propozycji przesyªów to:\n1) ((Ad)) →Ak oraz (Ak) −1 →0,\n2) ((L)) →Ak oraz |(Ak)| →(2),\n3) (Ak) →(L) oraz ((Ad) + 1) −((Ad)) →Ak,\n4) (Ak) −((L)) →Ak oraz (Ad) −(Ak) →1,\n5) (Ak) →(Ad) oraz ((Ad)) + ((Ad) + 1) →0,\n6) 3 ∗(Ak) →Ak oraz (0) + (1) →(Ad),\n7) 0 →(Ad) oraz |(0)| →(1),\n8) (Ak) →0 oraz ((Ad)) + 1 →(0).\nPo podaniu zada« warto przedyskutowa¢ ze studentami kwesti¦ interpretacji tre±ci (zadania podawane\ns¡ w notacji nawiasowej). Wa»ne jest, aby ka»dy z uczestników laboratorium dobrze zrozumiaª tre±¢\nswojego zadania. Prowadz¡cy mo»e zapyta¢ wybranych studentów o tre±¢ konkretnych zada«, podaj¡c\nprzykªady jak poni»ej.\n• Co oznacza zapis (Ak) →S?\n• Jak nale»y interpretowa¢ zapisy (Ad) →Ak, ((Ad)) →Ak oraz (((Ad))) →Ak?\n• Jak nale»y interpretowa¢ zapisy (Ak) →(Ad) oraz (Ak) →((Ad))?\n• Co stanowi bª¡d w zapisie (Ak) →Ad?\n• Dlaczego zapis Ak →Ad jest niepoprawny?\nProwadz¡cy zwraca równie» uwag¦ studentów, »e w tre±ciach zada« czasami, prócz nazw rejestrów, po-\njawiaj¡ si¦ konkretne warto±ci liczbowe. Prowadz¡cy przypomina, »e zawarto±ci poszczególnych rejestrów\nnie s¡ okre±lone, zatem odpowiednie warto±ci liczbowe nale»y \u0012wypracowa¢\u0011 (nie mo»na r¦cznie wpisy-\nwa¢ potrzebnych warto±ci do rejestrów maszyny W). Przy tej okazji mo»na przypomnie¢, jak uzyska¢ na\nprzykªad warto±¢\n8\nA. Momot\n• zero, jako realizacj¦ przesyªu (Ak) −(Ak) →Ak;\n• jeden, jako realizacj¦ przesyªu 0 →L, a nast¦pnie (L) + 1 →L.\nStudenci powinni te» pami¦ta¢ o mo»liwo±ci skorzystania z ró»nicy kolejnych warto±ci licznika, przed i po\njego inkrementacji.\nW kontek±cie pojawiaj¡cych si¦ liczb w zapisie nawiasowym warto te» zapyta¢ o interpretacj¦ poni»-\nszych zapisów.\n• Co oznaczaj¡ zapisy: 1 →Ak, (1) →Ak, ((1)) →Ak?\n• Co oznaczaj¡ zapisy: (Ak) →1, (Ak) →(1), (Ak) →((1))?\nStudenci proszeni s¡ o samodzieln¡ prac¦ przy projektowaniu przesyªów mi¦dzyrejestrowych z u»yciem\nsterowania r¦cznego w symulatorze maszyny W, natomiast prowadz¡cy, podchodz¡c do kolejnych sta-\nnowisk laboratoryjnych, sprawdza wyniki ich prac. Ka»dy ze studentów powinien pokaza¢ prowadz¡cemu\nswój projekt i potra\u001c¢ uzasadni¢ wybór aktywacji konkretnych sygnaªów steruj¡cych w poszczególnych\ntaktach rozwi¡zania.\nJe±li studenci zako«czyli ju» prac¦ nad swoim projektem i czekaj¡ na ocen¦ ich rozwi¡zania przez\nprowadz¡cego, powinni zosta¢ zach¦ceni do skonsultowania swoich rozwi¡za« z innymi oczekuj¡cymi.\nProwadz¡cy mo»e równie» zach¦ci¢ studentów do cichej dyskusji w maªych grupach i dzielenia si¦ swoimi\nspostrze»eniami z innymi. Mo»na te» zasugerowa¢ oczekuj¡cym studentom, aby zacz¦li przygotowywa¢\nsi¦ do kolejnej cz¦±ci laboratorium, której celem jest projektowanie rozkazów (studenci mog¡ pozna¢\nwcze±niej tre±ci swoich zada«).\n2.3. Projektowanie rozkazów oraz testowanie ich dziaªania\nTrzeci¡ i ostatni¡ cz¦±¢ zaj¦¢ laboratoryjnych stanowi praca wªasna studentów realizuj¡cych podane\nprzez prowadz¡cego przykªadowe rozkazy dla maszyny W lub rozszerzonej architektury W+. Na tym eta-\npie zakªada si¦, »e studenci potra\u001c¡ ju» samodzielnie zaprojektowa¢ przesyªy mi¦dzyrejestrowe stanowi¡ce\ntre±¢ rozkazów. Warto przypomnie¢ studentom, »e podczas projektowania rozkazu prócz zaprojektowania\nprzesyªu trzeba te» pami¦ta¢ o poprawnym wykonaniu caªego cyklu rozkazowego (\u0012pobierz, zdekoduj, wy-\nkonaj\u0011). Mo»na przy tym zde\u001cniowa¢ rozkaz bezczynno±ci NOP (ang. no-operation), który nic nie robi.\nMusi on zawiera¢ dwa takty:\n1) czyt wys wei il \u0015 realizuj¡cy odczytanie tre±ci rozkazu z pami¦ci operacyjnej, przesªanie go i zdeko-\ndowanie w rejestrze instrukcji oraz równocze±nie przygotowuj¡cy adres kolejnej instrukcji w rejestrze\nlicznika,\n2) wyl wea \u0015 realizuj¡cy przesªanie adresu kolejnej instrukcji do rejestru adresowego pami¦ci operacyjnej\ntak, aby w kolejnym takcie mo»na byªo poprawnie j¡ odczyta¢ (rozpocz¡¢ kolejny cykl instrukcji).\nPodkre±lamy przy tym, »e rejestr instrukcji i rejestr licznika s¡ bardzo wra»liwe na zmiany ze wzgl¦du\nna swoje funkcje. W trakcie caªego cyklu rozkazowego mo»na u»y¢ tylko jeden raz sygnaªu wei (sygnaª\nten powinien by¢ aktywowany tylko w pierwszym takcie3) oraz trzeba pami¦ta¢, aby w ostatniej fazie\nrozkazu rejestry L i A miaªy t¦ sam¡ zawarto±¢ \u0015 adres kolejnej instrukcji.\n3 Ka»dorazowe u»ycie sygnaªu wei powoduje na nowo dekodowanie rozkazu, którego kod znajduje si¦ w cz¦±ci kodowej\nrejestru instrukcji (a wtedy jego wªa±ciwa realizacja rozpoczyna si¦ w kolejnym takcie).\nProjektowanie rozkazów dla maszyny W \u0015 konspekt ¢wicze« laboratoryjnych\n9\nWarto przy tym wraz ze studentami omówi¢ kolejne takty kilku wybranych rozkazów ze standardowej\nlisty rozkazów maszyny W (widocznej wybieraj¡c menu Widok →Lista rozkazow lub przy u»yciu przyci-\nsku F10), zwracaj¡c uwag¦ zarówno na sposób podawania tre±ci rozkazu (aktywacja sygnaªów steruj¡cych,\n±redniki ko«cz¡ce takty), jak i sªowa kluczowe typu ROZKAZ, ARGUMENTY, KONIEC, JEELI itp.\nNa przykªadzie rozkazu SOM warto prze±ledzi¢ mo»liwo±¢ realizacji rozkazu warunkowego.\nDobrze jest pokaza¢ studentom, jak wprowadzi¢ kolejny rozkaz na list¦ rozkazów, wybieraj¡c menu\nPlik →Nowy →Rozkaz i wpisuj¡c w nowe okno nast¦puj¡c¡ tre±¢:\nROZKAZ NOP;\nARGUMENTY 0;\nczyt wys wei il;\nwyl wea;\nZwracamy uwag¦ na pojawiaj¡cy si¦ podczas kompilacji (prawy przycisk myszy Kompiluj lub CTRL+F9)\nkomunikat widoczny na rysunku 2, który informuje, »e rozkaz jest ju» zde\u001cniowany na li±cie rozkazów,\nale nie jest na razie dost¦pny. Mo»na zapyta¢ studentów jak rozumiej¡ ten komunikat i zasugerowa¢ im\npoprawn¡ odpowied¹. W tym celu przypominamy, ile rozkazów do tej pory widnieje na li±cie rozkazów\ni porównujemy t¦ liczb¦ z liczb¡ mo»liwych stanów, które mo»na zakodowa¢ na 3 bitach (w domy±lnej\narchitekturze maszyny W 3 bity sªu»¡ do kodowania rozkazu, a 5 bitów do kodowania adresu). Zatem\nrozwi¡zanie problemu niedost¦pno±ci nowego rozkazu polega na rozszerzeniu standardowej architektury\nmaszyny W o dodatkowy bit sªu»¡cy do kodowania rozkazu (menu Projekt →Opcje... →Architektura).\nWarto przy tym podkre±li¢, »e ten dodatkowy bit pozwala na poprawne dodanie 8 nowych rozkazów.\nRysunek 2. Komunikat o bª¦dzie\nNa koniec cz¦±ci wst¦pnej, zanim studenci zajm¡ si¦ prac¡ samodzieln¡, warto omówi¢ jeszcze w jaki\nsposób mo»na testowa¢ dziaªanie rozkazów. Mo»na to zrobi¢ na dwa alternatywne sposoby:\n1) poprzez \u0012obliczenie\u0011 kodów rozkazów i wprowadzenie r¦czne po»¡danych warto±ci do odpowiednich\nkomórek pami¦ci operacyjnej\n2) lub za pomoc¡ krótkiego programu napisanego w j¦zyku asemblera maszyny W (menu Plik →\nNowy →Program) i jego kompilacji (prawy przycisk myszy Kompiluj lub CTRL+F9), co powoduje\nwypeªnienie zawarto±ci pami¦ci operacyjnej odpowiednimi warto±ciami.\nMo»na pokaza¢ na przykªad program testuj¡cy rozkaz SOM (skok pod zadany adres, o ile zawarto±¢\nakumulatora jest ujemna):\nPOB A\nSOM B\nDOD A\n10\nA. Momot\nB: STP\nA: RST 10\nWarto zasugerowa¢ studentom ±ledzenie zawarto±ci rejestrów maszyny podczas wykonywania tego pro-\ngramu w trybie pracy krokowej4. Mamy przy tym dwie mo»liwo±ci: wykonywanie programu rozkaz po\nrozkazie (menu Wykonaj →Rozkaz lub F8) lub takt po takcie (menu Wykonaj →Takt lub F7).\nPo zako«czeniu dziaªania naszego programu testowego w akumulatorze powinni±my widzie¢ warto±¢ 20\n(podwojenie warto±ci zapisanej w komórce pami¦ci o adresie symbolicznym A). Mo»na teraz zmieni¢\nzawarto±¢ komórki A, wpisuj¡c zamiast RST 10, np. warto±¢ RST -10 i zobaczy¢, »e po skompilowaniu\ni ponownym uruchomieniu programu, po zako«czeniu dziaªania programu, w akumulatorze zostaje war-\nto±¢ -10. Jednak sposób prezentacji tej liczby zale»y od wybranego trybu wy±wietlania zawarto±ci rejestru\nAk i mo»emy zobaczy¢ -10 (gdy wy±wietlamy liczb¦ ze znakiem) lub 502 (w przypadku liczby bez znaku),\nlub 111110110 (binarnie).\nNale»y te» przypomnie¢ studentom o mo»liwo±ci realizacji rozkazów dwuargumentowych (przyjmu-\njemy wtedy, »e nast¦pny rozkaz znajduje si¦ 2 komórki dalej za projektowanym rozkazem, natomiast\nkomórka nast¦pna sªu»y do przekazania drugiego argumentu rozkazu). Wymagana jest wówczas dodat-\nkowa inkrementacja zawarto±ci licznika. Z kolei w przypadku rozkazów realizowanych z zastosowaniem\nadresacji po±redniej bardzo wa»ne jest odpowiednie zaplanowanie tre±ci programu testuj¡cego tak, aby\nodpowiednio zaprezentowa¢ dziaªanie rozkazu. W przypadku testowania rozkazów warunkowych nale-\n»y tak zaprojektowa¢ program testowy, aby mo»na byªo sprawdzi¢ dziaªanie obu wersji rozkazu. Warto\nte» zwróci¢ uwag¦, »e w wielu przypadkach do realizacji operacji arytmetycznych wykorzystywany jest\nakumulator, wi¦c (je±li nawet w tre±ci zadania nie wspomina si¦ wprost o odtwarzaniu jego warto±ci\npocz¡tkowej) o ile to mo»liwe nale»y zapami¦tywa¢ i przywraca¢ jego poprzedni¡ warto±¢.\nPodobnie jak uprzednio, podczas gdy studenci zaj¦ci s¡ samodzieln¡ prac¡ przy projektowaniu rozka-\nzów i testowaniu ich poprawno±ci, prowadz¡cy podchodzi do kolejnych stanowisk laboratoryjnych i spraw-\ndza wyniki prac studentów. Ka»dy ze studentów powinien umie¢ przedstawi¢ projekt rozkazu w postaci\npliku rozkazu oraz uruchomi¢ program testuj¡cy jego dziaªanie. Prowadz¡cy powinien zwraca¢ uwag¦ nie\ntylko na poprawno±¢ realizacji rozkazów, ale równie» na optymalizacj¦ czasow¡ ich dziaªania.\nKa»dy ze studentów dostaje do zaprojektowania dwa rozkazy: jeden prostszy (dla architektury W)\ni jeden trudniejszy (dla rozszerzonej architektury W+). Przykªadowe rozkazy podane s¡ poni»ej:",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "8) MN3 Ad: 3 ∗((Ad)) →Ak oraz D2 Ad (L)+1: ((Ad)) →((L) + 1).\n4 Nale»y przypomnie¢ studentom o potrzebie wyª¡czenia opcji sterowanie r¦czne w widoku jednostki centralnej.\nProjektowanie rozkazów dla maszyny W \u0015 konspekt ¢wicze« laboratoryjnych\n11\n2.4. Podsumowanie\nZwró¢my uwag¦, »e nie zawsze studenci s¡ odpowiednio przygotowani do zaj¦¢, a czasami po prostu\nw wolniejszym tempie przyswajaj¡ wiedz¦. Mo»na zatem zasugerowa¢ osobom, które nie byªy w stanie\ndoko«czy¢ realizacji wszystkich zada« w regulaminowym czasie (3 godziny zegarowe), napisanie spra-\nwozdania zawieraj¡cego rozwi¡zania wszystkich zada« wraz z odpowiednimi komentarzami i dodatkowy\nkontakt mailowy lub osobisty w czasie konsultacji. Mo»na te» zaleci¢ studentom, którzy nie czuj¡ si¦ zbyt\npewni w rozwi¡zywaniu prezentowanych zada«, aby w ramach zadania domowego spróbowali zrealizowa¢\npozostaªe zadania z listy zada« \u0015 takie, które nie zostaªy im przydzielone podczas zaj¦¢ laboratoryjnych.\nWarto przypomina¢ studentom, »e studiowanie wymaga od nich samodzielno±ci w wi¦kszym stopniu ni»\nmiaªo to miejsce w szkole ±redniej oraz aby nie zapominali o mo»liwo±ci regularnych konsultacji z prowa-\ndz¡cymi tak, aby w peªni wykorzysta¢ ich wiedz¦ w procesie nabywania nowych umiej¦tno±ci.\nPami¦tajmy te» o zaleceniach opisanych w ksi¡»ce Cele uczenia si¦. Jak pomóc uczniom zrozumie¢\nka»d¡ lekcj¦. Autorki ksi¡»ki stwierdzaj¡, »e nale»y zadawa¢ uczniom zadanie domowe, które jednak\n\u0012nie powinno nigdy wymaga¢ nauczenia si¦ czego± nowego albo wykonania ¢wiczenia, które nie b¦dzie\njasne [...]. Je±li rozwi¡zanie zadania domowego przyjdzie z du»ym trudem, oznacza to, »e utrwalone\nzostan¡ nie±cisªo±ci i braki w wiedzy. Uczniowie powinni uczy¢ si¦ nowych poj¦¢ i procesów podczas\nbie»¡cej lekcji, we wspóªpracy z nauczycielem. Zadanie domowe mo»e jednak by¢ efektywne i zosta¢\nwykorzystane w zwi¡zku z celem uczenia si¦, je±li poprosimy uczniów o wykonanie w domu pracy, która\nposzerza to, czego dokonali±my na lekcji, aby opanowa¢ dany materiaª\u0011 (zob. [5], s. 68). W podobnym\ntonie wypowiadaj¡ si¦ autorki ksi¡»ki Technologie informacyjno-komunikacyjne na lekcjach. Przykªadowe\nkonspekty i polecane praktyki, które stwierdzaj¡ ponadto, »e \u0012praca domowa powinna mie¢ sens, by¢ jasna\ni atrakcyjna; powinna te» dawa¢ wybór i zosta¢ bezzwªocznie sprawdzona\u0011 (zob. [6], s. 26).\nWarto te» pod koniec zaj¦¢ zada¢ studentom pytanie, w jakim stopniu przeprowadzone zaj¦cia po-\nmogªy im w osi¡gni¦ciu sukcesu zde\u001cniowanego na wst¦pie i zasugerowa¢ im zastanowienie si¦, co byªo\npomoc¡, a co przeszkod¡ w zdobywaniu nowych umiej¦tno±ci. Warto wysªucha¢ ich uwag tak, aby sam\nprowadz¡cy w przyszªo±ci mógª udoskonala¢ swój sposób przekazywania i wery\u001ckowania wiedzy.\nLiteratura",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. B.S. Bloom, J.T. Hastings, G.F. Madaus, Handbook of formative and summative evaluation of student\nlearning, McGraw-Hill, New York 1971.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. M. Chªopek, R. Tutajewicz, wiczenia laboratoryjne z Podstaw Informatyki \u0015 maszyna W, skrypt\nuczelniany Politechniki l¡skiej nr 2062. Wydawnictwo Politechniki l¡skiej, Gliwice 1997.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. J. Hattie, Visible learning: a synthesis of over 800 meta-analyses relating to achievement, Routledge,\nNew York 2009.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "5. C.M. Moss, S.M. Brookhart, Cele uczenia si¦. Jak pomóc uczniom zrozumie¢ ka»d¡ lekcj¦, Centrum\nEdukacji Obywatelskiej, Warszawa 2014.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. M. Ostrowska, D. Sterna, Technologie informacyjno-komunikacyjne na lekcjach. Przykªadowe kon-\nspekty i polecane praktyki, Centrum Edukacji Obywatelskiej, Warszawa 2015.",
    "source": "B-20-001 Konspekt.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "MINUT 2019 (1), s. 24–35\nAlina MOMOT1,\nRobert TUTAJEWICZ1\n1Wydział Automatyki, Elektroniki i Informatyki, Politechnika Śląska,\nul. Akademicka 16, 44-100 Gliwice\nMaszyna W – jak zaprojektować prosty rozkaz\nStreszczenie. Budowa współczesnych komputerów jest niezwykle skomplikowana, jednakże\nw większości przypadków ich podstawowa architektura opiera się na założeniach sformułowanych\nprzez Johna von Neumanna, Johna W. Mauchly’ego oraz Johna Presper Eckerta w 1945 roku. Tak\nwięc, aby zrozumieć podstawowe zasady działania komputera wystarczy prosty model komputera\nzaprojektowany w ten sposób, aby spełniał te założenia.\nW latach siedemdziesiątych ubiegłego wieku zespół pracowników Politechniki Śląskiej pod kie-\nrownictwem prof. Stefana Węgrzyna zaprojektował taki właśnie uproszczony model komputera\nwykładowego i nazwał go maszyną W. Niniejszy artykuł w skrótowy sposób opisuje budowę i spo-\nsób działania maszyny W oraz szczegółowo opisuje zasady projektowania prostych rozkazów dla\ntego modelowego komputera. W końcowej części artykułu zamieszczono również kilka przykładów\nzadań (projektów rozkazów) do samodzielnego wykonania wraz z rozwiązaniami.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Wstęp\nArchitektura komputera opisana przez Johna von Neumanna zakłada [2], że komputer jest urządze-\nniem składającym się z:\n• układu sterowania, którego głównym zadaniem jest pobieranie instrukcji z pamięci oraz ich se-\nkwencyjne przetwarzanie,\n• jednostki arytmetyczno-logicznej, w której przetwarzane są dane,\n• pamięci, w której przechowywane są dane oraz instrukcje programu,\n• urządzeń wejścia/wyjścia, które służą do interakcji z otoczeniem.\nPrzy czym dwoma podstawowymi rejestrami wchodzącymi w skład układu sterowania są:\n• rejestr instrukcji, który przechowuje kod wykonywanego rozkazu programu,\n• licznik rozkazów, który przechowuje adres następnej instrukcji, która ma być wykonana w ramach\nprogramu.\nAutor korespondencyjny: A. Momot (alina.momot@polsl.pl).\nData wpłynięcia: 07.11.2019.\nMaszyna W – jak zaprojektować prosty rozkaz\n25\nAby przybliżyć zasady działania komputerów kolejnym pokoleniom tworzone są uproszczone modele\nkomputerów. Przykładem tego może być między innymi Minivac 601 Digital Computer Kit – elektro-\nmechaniczny cyfrowy system komputerowy zaprojektowany w 1961 r. przez pioniera teorii informacji\nClaude’a Shannona jako zabawka edukacyjna ucząca zasad działania obwodów cyfrowych, czy też opisa-\nny przez Lindę Null i Julię Lobur prosty komputer MARIE (ang. A Machine Architecture that is Really\nIntuitive and Easy), za pomocą którego autorki prezentują przebieg cyklu rozkazu „pobierz, dekoduj, wy-\nkonaj” oraz pokazują sposób działania prawdziwych komputerów [4]. Autorki na stronie domowej książki\nudostępniają również symulator, który pozwala wykonywać programy napisane w asemblerze MARIE.\nW internecie dostępny jest również, na licencji BSD1, program komputerowy SPIM – symulator proce-\nsora MIPS (ang. Microprocessor without Interlocked Piped Stages), napisany przez profesora Jamesa R.\nLarus’a i zaprojektowany do uruchamiania kodu języka asemblera dla tej architektury typu RISC (ang.\nReduced Instruction Set Computing) [5]. Przy tej okazji warto też wspomnieć o witrynie internetowej\nnand2tetris.org, która to zawiera wszystkie materiały projektowe i narzędzia programowe niezbędne do\nzbudowania ogólnego systemu komputerowego od podstaw.\nRównież na Politechnice Śląskiej w zespole kierowanym przez prof. Węgrzyna powstał, w latach sie-\ndemdziesiątych ubiegłego wieku, projekt uproszczonego modelu komputera wykładowego mającego przy-\nbliżać studentom zasady działania komputerów [6]. Do dnia dzisiejszego, na wykładach z przedmiotu\nPodstawy Informatyki, studenci kierunku Informatyka zapoznają się na przykładzie tego modelu z pod-\nstawowymi zasadami działania komputerów [3]. Początkowo studenci szczegółowo poznawali te zasady\nćwicząc podczas zajęć laboratoryjnych na modelu ﬁzycznym – rzeczywistej implementacji projektu [1],\naczkolwiek obecnie do ćwiczeń tych wykorzystywany jest programowy symulator maszyny W.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Podstawy budowy i działania maszyny W\nMaszyna W to uproszczony model rzeczywistego komputera zaprojektowanego przy wykorzystaniu\narchitektury von Nemanna. Schemat podstawowej wersji maszyny W przedstawia rysunek 1.\nRysunek 1. Schemat podstawowej wersji maszyny W\n1Licencje BSD (Berkeley Software Distribution Licenses) zezwalają nie tylko na modyﬁkacje kodu źródłowego i jego\nrozprowadzanie w takiej postaci, ale także na rozprowadzanie produktu bez postaci źródłowej czy włączenia do zamkniętego\noprogramowania, pod warunkiem załączenia do produktu informacji o autorach oryginalnego kodu i treści licencji.\n26\nA. Momot, R. Tutajewicz\nW schemacie maszyny W można wyróżnić kilka podstawowych składowych, takich jak:\n• pamięć operacyjna (PaO), wraz z wyróżnionymi rejestrami: adresu A oraz słowa S,\n• jednostka arytmetyczno-logiczna (JAL), wraz z wyróżnionym rejestrem Akumulatora Ak i wcho-\ndzącym w jego skład bitem znaku Z,\n• układ sterujący, w którego skład wchodzą rejestr instrukcji I oraz licznika rozkazów L.\nElementy te połączone są poprzez magistralę słowową (zwaną również magistralą danych) i magistralę\nadresową. Przesyłanie danych miedzy tymi elementami jest sterowane za pomocą kilkunastu sygnałów\nbinarnych zwanych sygnałami sterującymi. Aby zrozumieć działanie całego układu należy najpierw za-\npoznać się z działaniem każdego z elementów składowych oraz rolą, jaką pełnią poszczególne sygnały\nsterujące.\n2.1. Pamięć operacyjna\nPamięć operacyjna (PaO) przechowuje program w postaci ciągu rozkazów komputera oraz dane, na\nktórych ten program jest wykonywany. W dowolnym momencie obliczeń, na życzenie procesora, pamięć\nudostępnia przechowywane przez siebie dane i rozkazy. Procesor ma także możliwość zapisywania w pa-\nmięci wyników wykonywanych przez siebie obliczeń.\nPamięć składa się z komórek, z których każda przechowuje pojedyncze słowo i jest identyﬁkowana\npoprzez numer komórki nazywany adresem. Aby wykonać jakąkolwiek operację na pamięci, procesor\nmusi zawsze podać adres komórki, której ta operacja dotyczy.\nAby odczytać określoną komórkę pamięci, należy najpierw wpisać adres komórki do rejestru adre-\nsowego pamięci A przy użyciu sygnału wea. Aktywacja tego sygnału umożliwia wpisanie do rejestru\nadresowego pamięci A adresu przesyłanego magistralą adresową. W następnym kroku możliwe jest od-\nczytanie odpowiedniej komórki z pamięci (operację aktywuje sygnał czyt, który wprowadza do rejestru\nsłowa S odczytaną wartość) i przesłanie odczytanej wartości na magistralę danych za pomocą sygnału\nwys.\nAby zapisać coś w pamięci, należy najpierw wpisać adres odpowiedniej komórki pamięci w rejestrze\nadresowym A (sygnał wea) oraz wprowadzić do rejestru słowowego pamięci S wartość, jaka ma być\nzapisana w pamięci przy użyciu sygnału wes. Aktywacja tego sygnału umożliwia przesłanie zawartości\nmagistrali danych do rejestru S. W następnym kroku należy aktywować sygnał pisz, który spowoduje\nzapisanie zawartości rejestru S w komórce pamięci, której adres znajduje się w rejestrze A.\n2.2. Jednostka arytmetyczno-logiczna\nJednostka arytmetyczno-logiczna (JAL) jest elementem procesora odpowiedzialnym za wykonywanie\nobliczeń takich jak dodawanie, odejmowanie, suma i iloczyn logiczny lub przesunięcia bitowe. Zakłada się\nprzy tym, że wynik obliczeń zostanie zapamiętany w rejestrze akumulatora Ak, będącym częścią składową\nJAL.\nPonieważ jednostka arytmetyczno-logiczna w maszynie W ma tylko jedno wejście, podczas wykonywa-\nnia operacji dwuargumentowych pierwszy argument, potrzebny do wykonania operacji, zostaje pobrany\nz akumulatora. Zatem należy pamiętać, aby przed wykonaniem właściwej operacji dwuargumentowej za-\ndbać o odpowiednie wypełnienie akumulatora (poprzez uprzednie wprowadzenie do akumulatora wartości\npierwszego argumentu planowanej do wykonania operacji). Można to zrealizować przy użyciu sygnału\nMaszyna W – jak zaprojektować prosty rozkaz\n27\nprzep, który aktywuje operację przepisywania stanu wejścia JAL. Do poprawnego wykonania operacji\nwprowadzenia wartości argumentu do rejestru akumulatora niezbędna jest również aktywacja sygnału\nweja, który umożliwia wprowadzenie na wejście JAL wartości podanej na magistralę danych, oraz sygna-\nłu weak, który umożliwia wprowadzenie wypracowanej w jednostce arytmetyczno-logicznej wartości do\nrejestru akumulatora. Podsumowując, aby wypełnić rejestr akumulatora wartością podaną na magistralę\ndanych, konieczna jest aktywacja trzech sygnałów: weja, przep oraz weak.\nW najprostszej wersji maszyny W (widocznej na rysunku 1), jednostka arytmetyczno-logiczna potraﬁ\nwykonywać tylko trzy operacje: przepisywanie stanu podanego na wejście (aktywowane sygnałem przep),\ndodawanie arytmetyczne2 (aktywowane sygnałem dod) i odejmowanie3 (aktywowane sygnałem ode). Sy-\ngnał weja powoduje udostępnienie wartości będącej na magistrali danych na wejście JAL, zaś sygnał\nweak pozwala wynik obliczeń zapisać do rejestru akumulatora. Zawartość rejestru akumulatora można\nwyprowadzić na magistralę danych przy użyciu sygnału wyak.\nObliczenia w JAL wykonywane są na liczbach binarnych zapisanych w kodzie uzupełnieniowym do 24.\nW dowolnym momencie obliczeń możliwe jest sprawdzenie, czy w akumulatorze znajduje się liczba ujem-\nna, czy też nieujemna. W tym celu wystarczy sprawdzić bit znaku liczby przechowywanej w akumulatorze\n(nazywany sygnałem stanu Z). Jeśli liczba w akumulatorze jest liczbą ujemną, bit Z będzie miał wartość\njeden. W przeciwnym przypadku bit ten będzie równy zero. Układ sterujący procesora może sterować\nwykonywaniem obliczeń w różny sposób w zależności od stanu bitu Z.\n2.3. Układ sterujący\nUkład sterujący, na podstawie stanu maszyny W (czyli zawartości poszczególnych rejestrów, two-\nrzących ten układ), określa sygnały sterujące, jakie w danym momencie mają być aktywne. Rejestrami\nwpływającymi na działanie układu sterującego oprócz akumulatora są rejestr instrukcji I oraz rejestr\nlicznika rozkazów L.\nLicznik rozkazów przechowuje adres kolejnego rozkazu do wykonania. Ponieważ najczęściej kolejne,\nnastępujące po sobie rozkazy znajdują się w kolejnych komórkach pamięci, do licznika rozkazów dodano\nsygnał il, którego zadaniem jest inkrementacja (czyli zwiększenie o 1) zawartości tego rejestru. Ponadto\nz licznikiem rozkazów związane są sygnały: wel, który aktywuje operację zapisania w rejestrze L aktu-\nalnej zawartości magistrali adresowej oraz wyl, który powoduje wyprowadzenie zawartości rejestru na tę\nmagistralę.\nW rejestrze instrukcji przez większość czasu wykonywania rozkazu znajduje się słowo opisujące wy-\nkonywany rozkaz. Rejestr ten można podzielić na dwie części: kodową i adresową (patrz rysunek 1).\nPierwsza część rejestru przechowuje kod rozkazu, zaś druga argument. Przy czym najczęściej argumen-\ntem jest adres komórki, do której odwołuje się dany rozkaz, stąd też nazwa drugiej części (część adresowa)\ni oznaczenie symboliczne Ad.\nZ rejestrem instrukcji związane są dwa sygnały: wyad oraz wei. Pierwszy z nich, sygnał wyad pozwala\nwyprowadzić argument (zawartość części adresowej rejestru I) na magistralę adresową. Drugi, sygnał wei\npozwala na przepisanie słowa opisującego rozkaz do wykonania z magistrali danych do rejestru I. Warto\nw tym miejscu podkreślić fakt, że szerokość (pojemność) magistrali adresowej i magistrali danych są\n2Do zawartości akumulatora dodawana jest wartość podana na wejście JAL.\n3Od zawartości akumulatora odejmowana jest wartość podana na wejście JAL.\n4Jest to system reprezentacji liczb całkowitych w dwójkowym systemie pozycyjnym. Jego nazwa wzięła się ze sposobu\nobliczania liczb przeciwnych: wartości przeciwne liczb n-bitowych uzyskujemy poprzez odjęcie tej liczby od 2n (uzupełnienie\ndo liczby 2n). Zatem na n bitach zapisujemy liczby z zakresu od −2n−1 do 2n−1 −1, przy czym pierwszy, najstarszy bit,\ntraktujemy jako tak zwany bit znaku. Jego wartość równa 1 oznacza liczbę ujemną, zaś 0 dodatnią.\n28\nA. Momot, R. Tutajewicz\nróżne. W przypadku najprostszej wersji maszyny W, magistralą danych można przesyłać słowa 8-bitowe,\nnatomiast magistralą danych – słowa 5-bitowe.\n2.4. Sygnały sterujące: impulsowe i poziomowe\nPodczas analizy pracy maszyny W należy zwrócić uwagę na fakt, że układ sterujący jest układem\nsekwencyjnym synchronicznym, zatem wymaga do prawidłowej pracy sygnału zegarowego (taktującego).\nWszystkie operacje wewnątrz jednostki centralnej jak i operacje w całym systemie odbywają się w takt\nsygnału zegarowego, który to sygnał powinien być doprowadzony do wszystkich elementów systemu. Czę-\nstotliwość sygnału zegarowego ma bezpośredni wpływ na szybkość operacji wykonywanych przez procesor,\nukłady pamięci czy też urządzenia wejścia/wyjścia. Odwrotność częstotliwości generatora zegarowego to\nokres sygnału zegarowego nazywany zwykle cyklem zegarowym lub taktem zegara.\nNa schemacie maszyny W widocznym na rysunku 1 można wyróżnić 16 sygnałów sterujących. Sygnały\nte można podzielić na dwie kategorie:\n• sygnały impulsowe – bardzo krótkie sygnały aktywowane na koniec taktu sygnału zegarowego (wy-\nróżnione na rysunku poprzez podkreślenie ich nazw) oraz\n• sygnały poziomowe – długie sygnały, aktywne przez całą długość taktu sygnału zegarowego.\nSygnały poziomowe służą przede wszystkim do aktywowania operacji wyprowadzania danych zapisanych\nw rejestrach na magistrale, natomiast sygnały impulsowe używane są w celu wpisywania nowych da-\nnych do rejestrów. Wynika to z faktu iż wyprowadzając daną wartość z rejestru na magistralę musi minąć\npewien czas, aby pojawiająca się na magistrali dana wartość mogła być traktowana jako wiarygodna (sta-\nbilny poziom napięcia). Dopiero wtedy (pod koniec taktu zegarowego) można tę daną wartość przepisać\ndo kolejnego rejestru.\nOperacje aktywowane poszczególnymi sygnałami sterującymi można opisać używając symboliki prze-\nsyłów międzyrejestrowych5:\n• dla sygnałów poziomowych\n1. wyl : (L) →magA – wyprowadzenie zawartości rejestru licznika na magistralę adresową,\n2. wyad : (Ad) →magA – wyprowadzenie zawartości części adresowej rejestru instrukcji na\nmagistralę adresową,\n3. wyak : (Ak) →magS – wyprowadzenie zawartości rejestru akumulatora na magistralę danych,\n4. wys : (S) →magS – wyprowadzenia zawartości rejestru słowa pamięci operacyjnej na magi-\nstralę danych,\n5. pisz : (S) →(A) – wpisanie zawartości rejestru słowa S pamięci operacyjnej do komórki\npamięci o adresie zawartym w rejestrze adresowym A pamięci operacyjnej,\n6. czyt : ((A)) →S – wpisanie zawartości komórki pamięci o adresie zawartym w rejestrze\nadresowym A pamięci operacyjnej do rejestru słowa S,\n7. weja : (magS) →JAL – wpisanie wartości podanej na magistralę danych na wejście jednostki\nartymetyczno-logicznej,\n5Zakładając, że R oznacza rejestr o nazwie R, zapis (R) oznacza zawartość rejestru R, natomiast ((R)) zawartość komórki\npamięci o adresie wpisanym do rejestru R.\nMaszyna W – jak zaprojektować prosty rozkaz\n29\n8. przep – przepisanie danej podanej na na wejście jednostki artymetyczno-logicznej,\n9. dod – dodanie do zawartości rejestru akumulatora wartości podanej na wejście JAL,\n10. ode – odjęcie od zawartości rejestru akumulatora wartości podanej na wejście JAL,\n• dla sygnałów impulsowych\n1. wel : (magA) →L – wprowadzenie zawartości magistrali adresowej do rejestru licznika,\n2. wea : (magA) →A – wprowadzenie zawartości magistrali adresowej do rejestru adresowego\npamięci operacyjnej,\n3. wes : (magS) →S – wprowadzenie zawartości magistrali danych do rejestru słowa pamięci\noperacyjnej,\n4. wei : (magS) →I – wprowadzenie zawartości magistrali danych do rejestru instrukcji,\n5. weak : (JAL) →Ak – wprowadzenie wypracowanej w jednostce arytmetyczno-logicznej war-\ntości do rejestru akumulatora,\n6. il : (L) + 1 →L – inkrementacja zawartości rejestru licznika.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. Projektowanie rozkazów\nJednym z etapów projektowania procesora jest ustalenie listy rozkazów realizowanych przez dany pro-\ncesor oraz zdeﬁniowanie, dla każdego rozkazu, sekwencji działań potrzebnych do jego wykonania. Pod\npojęciem projektowania rozkazu będziemy rozumieć ustalenie przebiegów sygnałów sterujących, aktywu-\njących wykonanie wszystkich przesyłów międzyrejestrowych, składających się na dany rozkaz.\nKażdy rozkaz wykonywany jest etapami. Pierwszy etap to pobranie i zdekodowanie rozkazu. Dopiero\npo zakończeniu tego etapu procesor jest w stanie określić jaki rozkaz wykonuje. Oznacza to, że etap\npobrania i dekodowania musi być wykonywany identycznie dla wszystkich projektowanych rozkazów.\nW maszynie W wykonanie tego etapu realizowane jest jako pierwsza faza rozkazu i składają się na nią\nsygnały: czyt (odczytanie komórki pamięci), wys (przesłanie zawartości odczytanej komórki na magistralę\ndanych), wei (wprowadzenie odczytanej zawartości do rejestru instrukcji) i il (inkrementacja licznika\nrozkazów). Przy czym zakłada się, że w momencie odczytu zawartości komórki pamięci operacyjnej,\nw rejestrze adresowym pamięci operacyjnej A oraz rejestrze licznika znajduje się ta sama wartość – adres\nmającego się wykonać rozkazu. Należy też podkreślić, że w poprawnie zaprojektowanym rozkazie sygnał\nwei występuje zawsze tylko i wyłącznie w pierwszej fazie rozkazu (zatem przez wszystkie kolejne fazy\npotrzebne do zrealizowania rozkazu jego kod znajduje się w części kodowej rejestru instrukcji).\nW kolejnych fazach realizowane są dalsze etapy wykonania rozkazu. Są to: ustalenie adresu efektyw-\nnego argumentu, jego odczyt i wykonanie na nim właściwej operacji oraz przygotowanie do wykonania\nnastępnego rozkazu (zadbanie o to, aby w rejestrze adresowym pamięci operacyjnej A oraz rejestrze licz-\nnika znajdowała się ta sama wartość – adres kolejnego rozkazu do wykonania). Cały proces projektowania\nrozkazów zostanie przedstawiony na przykładzie opisanych poniżej rozkazów DOD, ŁAD oraz SOM.\n3.1. Rozkaz DOD\nDziałanie rozkazu DOD można opisać symbolicznie za pomocą przesyłu międzyrejestrowego:\n(Ak) + ((Ad)) →Ak.\n30\nA. Momot, R. Tutajewicz\nW wyniku działania tego rozkazu do rejestru akumulatora jednostki arytmetyczno-logicznej należy dodać\nzawartość komórki pamięci, której adres jest podany jako argument projektowanego rozkazu i znajduje\nsię w części adresowej rejestru instrukcji (po pobraniu i zdekodowaniu rozkazu). Wynik dodawania należy\nzapisać w rejestrze akumulatora.\nPodobnie jak w przypadku każdego innego rozkazu, projektowanie rozkazu zaczniemy od fazy pobrania\ni dekodowania rozkazu. Najpierw należy odczytać rozkaz z pamięci i przesłać go do rejestru instrukcji\noraz zwiększyć o 1 zawartość licznika rozkazów. Wykonanie tych działań wymaga uaktywnienia sygnałów\nczyt, wys, wei oraz il. Te właśnie sygnały będą tworzyć pierwszą fazę wykonania rozkazu dodawania.\nPo zdekodowaniu konkretnego rozkazu można przystąpić do realizacji charakterystycznych dla nie-\ngo działań. W tym przypadku do akumulatora musimy dodać zawartość komórki pamięci, której adres\njest argumentem rozkazu. Samo dodawanie musi być poprzedzone odczytaniem zawartości odpowiedniej\nkomórki pamięci. Należy przy tym pamiętać, że przy aktywacji sygnału czyt zawsze odczytywana jest\nkomórka, której adres znajduje się w rejestrze adresowym układu pamięci (rejestrze A). Tymczasem adres\nkomórki, którą mamy odczytać znajduje się w części adresowej (Ad) rejestru instrukcji. Przed odczyta-\nniem z pamięci należy zatem przesłać zawartość rejestru Ad do rejestru A, co można zapisać symbolicznie\njako (Ad) →A. Przesył taki będzie wykonany po uaktywnieniu sygnałów wyad (wyprowadzenie zawar-\ntości części adresowej rejestru instrukcji na magistralę adresową) i wea (zapisanie zawartości magistrali\nadresowej w rejestrze A układu pamięci). Te dwa sygnały (wyad i wea) tworzą drugą fazę realizacji\nrozkazu dodawania.\nWszystkie pozostałe czynności zostaną wykonane w trzeciej fazie wykonania tego rozkazu. A będą to:\n– odczytanie argumentu z pamięci (aktywowane sygnałem czyt),\n– przesłanie go do jednostki arytmetyczno-logicznej (co wymaga sygnałów wys i weja),\n– wykonanie dodawania (sygnał dod) i zapisanie jego wyniku w akumulatorze (sygnał weak).\nCzynności te można zapisać symbolicznie jako (Ak) + ((A)) →Ak. Dodatkowo, ponieważ trzecia faza\nbędzie ostatnią fazą realizacji rozkazu dodawania, musimy pamiętać o przesłaniu adresu następnego\nrozkazu do wykonania z rejestru licznika rozkazów L do rejestru adresowego pamięci A, co można zapisać\nsymbolicznie jako (L) →A. Ten przesył zostanie zrealizowany dzięki sygnałom wyl i wea.\nWarto przy tym też zwrócić uwagę na pewną optymalizację działań. Z uwagi na fakt iż przesył\n(Ak) + ((A)) →Ak jest niezależny od przesyłu (L) →A, a transfer danych w każdym z nich zajmuje\ninną magistralę (odpowiednio magistralę danych i adresową), operacje związane z tymi przesyłami mogą\nbyć wykonane w tym samym takcie zegarowym.\nWidzimy więc, że rozkaz dodawania DOD tworzą trzy fazy (takty zegara), w których muszą być\naktywne następujące sygnały sterujące:\n1. czyt wys wei il;\n2. wyad wea;\n3. czyt wys weja dod weak wyl wea.\n3.2. Rozkaz ŁAD\nDziałanie rozkazu ŁAD można opisać symbolicznie za pomocą przesyłu międzyrejestrowego:\n(Ak) →(Ad).\nW wyniku działania tego rozkazu zawartość rejestru akumulatora jednostki arytmetyczno-logicznej należy\nwpisać do komórki pamięci, której adres jest podany jako argument projektowanego rozkazu i znajduje\nsię w części adresowej rejestru instrukcji (po pobraniu i zdekodowaniu rozkazu).\nMaszyna W – jak zaprojektować prosty rozkaz\n31\nJak wspomniano uprzednio pierwszy takt każdego rozkazu rozpoczyna się od fazy pobrania i dekodo-\nwania rozkazu. Należy zatem odczytać rozkaz z pamięci i przesłać go do rejestru instrukcji oraz zwiększyć\no 1 zawartość licznika rozkazów. Wykonanie tych działań wymaga uaktywnienia sygnałów czyt, wys, wei\noraz il. Te właśnie sygnały będą tworzyć pierwszą fazę wykonania rozkazu.\nPo zdekodowaniu rozkazu można przystąpić do charakterystycznych dla niego działań. Ponieważ ak-\ntywny sygnał pisz powoduje zapis wartości zapisanej w rejestrze słowa S pamięci operacyjnej do komórki\npamięci o adresie zawartym w rejestrze adresowym A pamięci operacyjnej, przed wykonaniem operacji\nzapisu należy odpowiednio wypełnić rejestry uczestniczące w tej operacji. Zatem do rejestru S należy\nprzesłać zawartość rejestru akumulatora, co można symbolicznie zapisać jako (Ak) →S. Przesył ta-\nki będzie wykonany po uaktywnieniu sygnałów wyak (wyprowadzenie zawartości rejestru akumulatora\nna magistralę danych) oraz wes (zapisanie zawartości magistrali danych w rejestrze S układu pamięci).\nNależy także przesłać zawartość części adresowej Ad rejestru instrukcji do rejestru adresowego pamięci\noperacyjnej A, co można zapisać symbolicznie jako (Ad) →A. Przesył taki będzie wykonany po uak-\ntywnieniu sygnałów wyad (wyprowadzenie zawartości części adresowej rejestru instrukcji na magistralę\nadresową) i wea (zapisanie zawartości magistrali adresowej w rejestrze adresowym układu pamięci).\nZ uwagi na fakt iż oba przesyły (Ak) →S oraz (Ad) →A są niezależne od siebie, a transfer danych\nw każdym z nich zajmuje inną magistralę (odpowiednio magistralę danych i adresową), operacje związane\nz tymi przesyłami mogą być wykonane w tym samym takcie zegarowym. Odbywać się to będzie drugim\ntakcie naszego rozkazu, który będą tworzyć sygnały wyak, wes oraz wyad, wea.\nPo wpisaniu odpowiednich wartości do rejestru słowa i rejestru adresowego pamięci operacyjnej, w ko-\nlejnym (trzecim) takcie należy aktywować sygnał zapisu pisz. Dodatkowo, ponieważ trzecia faza będzie\nostatnią fazą realizacji rozkazu, musimy pamiętać o przesłaniu adresu następnego rozkazu do wykonania\nz rejestru licznika rozkazów L do rejestru adresowego pamięci A, co można zapisać symbolicznie jako\n(L) →A. Ten przesył zostanie zrealizowany dzięki sygnałom wyl i wea.\nWidzimy więc, że rozkaz ŁAD tworzą trzy fazy (takty zegara), w których muszą być aktywne nastę-\npujące sygnały sterujące:\n1. czyt wys wei il;\n2. wyak wes wyad wea;\n3. pisz wyl wea.\n3.3. Rozkaz SOM\nDziałanie rozkazu SOM można opisać symbolicznie za pomocą przesyłu międzyrejestrowego:\njeżeli Z=1, to\n(Ad) →L.\nW wyniku działania tego rozkazu zawartość części adresowej rejestru instrukcji powinna zostać wpisana do\nrejestru licznika, o ile tylko zawartość rejestru akumulatora jednostki arytmetyczno-logicznej jest ujemna.\nOznacza to, że rozkaz ten powoduje ustalenie adresu następnego do realizacji rozkazu w zależności od\nzawartości akumulatora. Jeżeli w akumulatorze jest liczba nieujemna, następnym wykonywanym rozkazem\nma być rozkaz znajdujący się w kolejnej komórce pamięci. Natomiast jeżeli zawartość akumulatora jest\nujemna, następnym rozkazem do wykonania ma być ten, który zapisano w komórce pamięci o adresie\npodanym jako argument rozkazu.\nJak zwykle pierwszą fazę projektowanego rozkazu tworzą sygnały czyt, wys, wei, il. Następnie należy\nsprawdzić, czy w akumulatorze znajduje się wartość ujemna. Jest to możliwe dzięki istnieniu odpowiednich\nsygnałów stanu procesora. W tym wypadku interesuje nas wartość bitu znaku Z rejestru akumulatora,\n32\nA. Momot, R. Tutajewicz\nczyli znak liczby przechowywanej w akumulatorze. Sygnał stanu Z informuje procesor czy w akumulatorze\njest liczba ujemna (wtedy bit ten przyjmuje wartość 1).\nRozkaz SOM jest więc rozkazem skoku warunkowego. Jeżeli Z = 1, to w akumulatorze jest liczba\nujemna, a to oznacza, że należy wykonać skok, czyli przesłać do rejestrów L i A adres znajdujący się\nw części adresowej rejestru instrukcji, co można zapisać symbolicznie jako (Ad) →L, A. Wymaga to\nuaktywnienia sygnałów wyad, wel oraz wea. Warto przy tym podkreślić, że przesył (Ad) →A realizowany\nrównocześnie z (Ad) →L wynika z optymalizacji, czyli dążenia do uzyskania pożądanego efektu w\nminimalnej liczbie taktów zegarowych. Zamiast więc realizować dwa przesyły: najpierw (Ad) →L, a\npotem (L) →A, wykorzystujemy fakt, że w obu wypadkach przesyłana jest ta sama wartość, po tej\nsamej magistrali.\nJeżeli Z = 0, to w akumulatorze jest liczba nieujemna, więc jedynie musimy zakończyć nasz bieżący\nrozkaz, przygotowując w rejestrze adresowym pamięci A adres kolejnego rozkazu. Adres następnego roz-\nkazu znajduje się w rejestrze licznika L (po wykonaniu inkrementacji w pierwszej fazie), zatem wystarczy\ngo przesłać do rejestru A. Z tym przesyłem związane są sygnały wyl, wea.\nWidzimy więc, że rozkaz dodawania SOM tworzą dwie fazy (takty zegara), w których muszą być\naktywne następujące sygnały sterujące:\n1. czyt wys wei il;\nJeżeli Z=1\n2. wyad wel wea;\nw przeciwnym przypadku\n2.’ wyl wea.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. Zadania do samodzielnego wykonania\nNa zakończenie proponuje się Czytelnikowi samodzielne wykonanie kilku zadań, sformułowanych\nw dalszej części niniejszej sekcji, w celu utrwalenia opisywanych wyżej wiadomości i zasad projektowych.\nPod treścią zadań zamieszczono ich rozwiązania w postaci opisu działania rozkazu w języku naturalnym\noraz wyszczególniono nazwy niezbędnych sygnałów sterujących, które należy aktywować w poszczególnych\nfazach rozkazu. Przy czym sugeruje się czytelnikowi próbę samodzielnego zmierzenia się ze zrozumieniem\nsymboliki rozkazu, wskazania aktywnych sygnałów sterujących oraz zastanowienia się nad optymaliza-\ncją czasową proponowanego rozwiązania, a dopiero potem, na koniec, porównanie swoich przemyśleń\nz gotowym (optymalnym) rozwiązaniem.\n4.1. Treści zadań\nZaprojektować rozkazy opisane w sposób symboliczny jako:\n1. 2 ∗(Ak) →Ak,\n2. 3 ∗(Ak) →Ak,\n3. 5 ∗(Ak) →Ak,\n4. 8 ∗(Ak) →Ak,\n5. −(Ak) →Ak,\nMaszyna W – jak zaprojektować prosty rozkaz\n33\n6. ((L) + 1) →(Ad),\n7. jeżeli Z = 1, to (Ak) −((Ad)) →Ak,\n8. jeżeli Z = 1, to 2 ∗(Ak) →Ak, (Ad),\n9. jeżeli ((Ad)) < 0, to 0 →Ak, (Ad);\nw przeciwnym przypadku ((Ad)) →Ak,\n10. jeżeli (Ak) < ((Ad)), to (Ak) −2 ∗((Ad)) →Ak.\n4.2. Rozwiązania zadań",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Rozkaz powinien zrealizować podwojenie zawartości akumulatora. Do jego wykonania potrzebne są\n2 fazy (takty zegara), w których muszą być aktywne następujące sygnały sterujące:\n1. czyt wys wei il;\n2. wyak weja dod weak wyl wea.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Rozkaz powinien zrealizować potrojenie zawartości akumulatora. Do jego wykonania potrzebne są\n3 fazy (takty zegara), w których muszą być aktywne następujące sygnały sterujące:\n1. czyt wys wei il;\n2. wyak weja dod weak wes;\n3. wys weja dod weak wyl wea.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. Rozkaz powinien zrealizować pięciokrotone zwiększenie zawartości akumulatora. Do jego wykonania\npotrzebne są 4 fazy (takty zegara), w których muszą być aktywne następujące sygnały sterujące:\n1. czyt wys wei il;\n2. wyak weja dod weak wes;\n3. wyak weja dod weak;\n4. wys weja dod weak wyl wea.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. Rozkaz powinien zrealizować ośmiokrotne zwiększenie zawartości akumulatora. Do jego wykonania\npotrzebne są 4 fazy (takty zegara), w których muszą być aktywne następujące sygnały sterujące:\n1. czyt wys wei il;\n2. wyak weja dod weak;\n3. wyak weja dod weak;\n4. wyak weja dod weak wyl wea.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "5. W wyniku działania rozkazu wartość zawarta akumulatorze powinna zostać zmieniona na przeciwną.\nDo jego wykonania potrzebne są 3 fazy (takty zegara), w których muszą być aktywne następujące\nsygnały sterujące:\n1. czyt wys wei il;\n2. wyak weja ode weak wes;\n3. wys weja ode weak wyl wea.\n34\nA. Momot, R. Tutajewicz",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. W wyniku działania rozkazu w pamięci, pod adresem podanym argumentem rozkazu, powinna zo-\nstać wpisana wartość zapisana w kolejnej komórce pamięci operacyjnej względem komórki pamięci,\nw której znajduje się dany rozkaz. Do jego wykonania potrzebne są 4 fazy (takty zegara), w których\nmuszą być aktywne następujące sygnały sterujące:\n1. czyt wys wei il;\n2. wyl wea;\n3. czyt wyad wea il6;\n4. pisz wyl wea.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "7. Rozkaz powinien zrealizować odejmowanie od zawartości akumulatora zawartości komórki pamięci,\nktórej adres podany jest argumentem rozkazu, o ile tylko zawartość rejestru akumulatora jednostki\narytmetyczno-logicznej jest ujemna. Do jego wykonania potrzebne są maksymalnie 3 fazy (takty\nzegara), w których muszą być aktywne następujące sygnały sterujące:\n1. czyt wys wei il;\nJeżeli Z=1\n2. wyad wea;\n3. czyt wys weja ode weak wyl wea;\nw przeciwnym przypadku\n2.’ wyl wea.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "8. Rozkaz powinien zrealizować podwojenie zawartości akumulatora, a następnie wyznaczoną wartość\npozostawić w akumulatorze i wpisać do komórki pamięci, której adres podany jest argumentem\nrozkazu, o ile tylko zawartość rejestru akumulatora jednostki arytmetyczno-logicznej jest ujemna.\nDo jego wykonania potrzebne są maksymalnie 4 fazy (takty zegara), w których muszą być aktywne\nnastępujące sygnały sterujące:\n1. czyt wys wei il;\nJeżeli Z=1\n2. wyak weja dod weak;\n3. wyak wes wyad wea;\n4. pisz wyl wea;\nw przeciwnym przypadku\n2.’ wyl wea.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "9. W wyniku działania rozkazu wartość zero należy wpisać do akumulatora i do komórki pamięci, któ-\nrej adres podany jest argumentem rozkazu, o ile tylko zawartość tej komórki pamięci była ujemna.\nW przeciwnym przypadku do akumulatora należy wpisać zawartość komórki pamięci, której adres\npodany jest argumentem rozkazu. Do jego wykonania potrzebne jest maksymalnie 6 faz (taktów\nzegara), w których muszą być aktywne odpowiednio sygnały sterujące:\n1. czyt wys wei il;\n2. wyad wea;\n3. czyt wys weja przep weak wyl wea;\n6Aktywny sygnał il w tej fazie rozkazu świadczy o tym, że projektując ten rozkaz zakładamy, że w komórce za rozkazem\nznajduje się drugi argument rozkazu. Kolejny zaś rozkaz zapisany jest nie w kolejnej komórce za danym rozkazem, ale w w\nkomórce następnej, tj. o adresie (L)+2.\nMaszyna W – jak zaprojektować prosty rozkaz\n35\nJeżeli Z=1\n4. wyak weja ode weak;\n5. wyak wes wyad wea;\n6. pisz wyl wea;",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "10. Rozkaz powinien zrealizować odejmowanie od zawartości akumulatora podwojonej zawartości ko-\nmórki pamięci, której adres podany jest argumentem rozkazu, o ile tylko zawartość tej komórki\npamięci jest większa od wartości będącej przed wykonaniem rozkazu w akumulatorze. Do jego\nwykonania potrzebne są maksymalnie 4 fazy (takty zegara), w których muszą być aktywne odpo-\nwiednio sygnały sterujące:\n1. czyt wys wei il;\n2. wyad wea;\n3. czyt wys weja ode weak;\nJeżeli Z=1\n4. wys weja ode weak wyl wea;\nw przeciwnym przypadku\n4.’ wys weja dod weak wyl wea.\nLiteratura",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. M. Chłopek, R. Tutajewicz, Ćwiczenia laboratoryjne z Podstaw Informatyki – maszyna W. Skrypt\nuczelniany Politechniki Śląskiej nr 2062. Wydawnictwo Politechniki Śląskiej, Gliwice, 1997.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. H.H. Goldstine, The Computer: from Pascal to von Neumann. Princeton, New Jersey: Princeton\nUniversity Pres, 1972.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. K. Grochla, G. Hryń, S. Iwaszenko, P. Kasprzyk, J. Kubica, M. Widera, T. Wróbel, Wykłady z Pod-\nstaw Informatyki profesora Stefana Węgrzyna. Skrypt uczelniany Politechniki Śląskiej nr 2321. Wy-\ndawnictwo Politechniki Śląskiej, Gliwice, 2003.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. L. Null, J. Lobur, Struktura organizacyjna i architektura systemów komputerowych. Helion, Gliwice,\n2004.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "5. D.A. Patterson, J.L. Hennessy, Computer Organization and Design: The Hardware/Software Inter-\nface, wydanie piąte, Elsevier Morgan Kaufmann, Oxford, 2014.",
    "source": "C-19-004_Maszyna.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "MINUT 2020 (2), s. 136\u0015148\nISSN 2719-3063\nRobert BRZESKI1[0000 −0001 −7127 −0989]\n1Wydziaª Automatyki, Elektroniki i Informatyki, Politechnika l¡ska, ul. Akademicka 16, 44-100 Gliwice\nPrawidªowe tworzenie rozkazów asemblerowych dla Maszyny W\ncz.2\nStreszczenie. Artykuª ten stanowi kontynuacj¦ tematyki rozpocz¦tej w artykule `Prawidªowe\ntworzenie rozkazów asemblerowych dla Maszyny W cz.1'. W bie»¡cym artykule przedstawiony jest\nkolejny zestaw bª¦dów popeªnianych przez studentów. Tym razem s¡ to bª¦dy zwi¡zane z bardziej\ndogª¦bn¡ wiedz¡ lub takie które mimo wszystko na zaj¦ciach si¦ pojawiaj¡. W tym artykule s¡ one\nzebrane w jeden zbiór, wraz z krótkim omówieniem problemu i przedstawieniem rozwi¡za« prawi-\ndªowych. Podsumowaniem jest spis opisanych tu bª¦dów popeªnianych przez studentów. Artykuª\nten mo»e stanowi¢ wi¦c nie tylko uzupeªnienia wiedzy dotychczas posiadanej, ale tak»e swego ro-\ndzaju list¦ kontroln¡ podczas praktycznej implementacji rozkazów asemblerowych dla Maszyny W.\nSªowa kluczowe: rozkaz, asembler, Maszyna W.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Wprowadzenie do implementacji rozkazów dla Maszyny W\nBie»¡cy artykuª, jako kontynuacja tematyki zawartej w publikacji `Prawidªowe tworzenie rozkazów\nasemblerowych dla Maszyny W cz.1' [6], jest przeznaczony dla studentów maj¡cych styczno±¢ lub chc¡-\ncych poszerzy¢ swoj¡ wiedz¦ z zakresu projektowania rozkazów dla Maszyny W. Zagadnienie to poruszane\njest mi¦dzy innymi na wydziale Automatyki Elektroniki i Informatyki Politechniki l¡skiej, w ramach\nprzedmiotu Postawy Informatyki. Poj¦cie Maszyny W odnosi si¦ do idei konstrukcji i dziaªania uprosz-\nczonego komputera. Zawiera on w sobie podstawowe, najwa»niejsze elementy maszyny cyfrowej, zgodnej\nz obecnie powszechnie u»ywan¡ architektur¡ von Neumanna. Na prowadzonych zaj¦ciach, w szczególno±ci\npodczas laboratorium, studenci u»ywaj¡ Maszyny W, w postaci programowego symulatora [Rysunek 1].\nNa zaj¦ciach z tego przedmiotu zadaniem studenta jest zaimplementowanie przy u»yciu mikrosygnaªów\nrozkazu asemblerowego, zgodnie z otrzyman¡ tre±ci¡ opisuj¡c¡ co dokªadnie dany rozkaz ma realizowa¢.\nPrzed implementacj¡ rozkazu mo»na utworzy¢ jego projekt w postaci algorytmu, zapisanego w dowol-\nny sposób (np. sªownie lub przy u»yciu schematu blokowego, lub za pomoc¡ poszczególnych przesyªów\npomi¦dzy rejestrami lub pami¦ci¡). Taki rozkaz wykonywany jest w kilku osobnych cyklach procesora\nzwanych taktami. W ka»dym takcie nale»y umie±ci¢ odpowiedni zestaw sygnaªów mikrosteruj¡cych i za-\nko«czy¢ go znakiem reprezentuj¡cym koniec taktu. Dla obecnie u»ywanego na laboratorium symulatora\nAutor korespondencyjny: R. Brzeski (Robert.Brzeski@polsl.pl).\nData wpªyni¦cia: 01.10.2020.\nPrawidªowe tworzenie rozkazów asemblerowych dla Maszyny W cz.2\n137\njest to ±rednik. Implementacja rozkazu na dost¦pnym symulatorze realizowana jest w oknie, dost¦pnym\npo wybraniu z menu Plik →Nowy →Rozkaz, w nast¦puj¡cej postaci [6]:\n// Dwa znaki uko±nika oznaczaj¡ komentarz. Jest on opcjonalny ale warto tu wpisa¢ tre±¢ rozkazu która\nb¦dzie implementowana.\nROZKAZ nazwaRozkazu;\nNast¦pnie trzeba umie±ci¢ prede\u001cniowane sªowo `ROZKAZ' oraz wªasn¡ nazw¦ implementowanego\nrozkazu. Caªo±¢ trzeba zako«czy¢ ±rednikiem.\nArgumenty liczbaArgumentów;\nKolejn¡, tym razem opcjonaln¡ cz¦±ci¡ jest wpisanie liczby argumentów obsªugiwanych przez im-\nplementowany rozkaz. Warto±ci¡ domy±ln¡ jest jeden.\nczyt wys wei il;\nPierwszy takt rozkazu. Jest on zawsze taki sam \u0015 nie mo»na tu nic doda¢ ani niczego pomin¡¢. Dla\nka»dego rozkazu skªada si¦ z zestawu tych samych czterech mikrosygnaªów.\nKolejne takty \u0015 zestawy mikrosygnaªów;\nKa»dy takt trzeba zako«czy¢ ±rednikiem.\nRysunek 1. Widok okna symulatora Maszyny W, w wersji W+\nTak zaimplementowany rozkaz, mo»na skompilowa¢ poprzez wybranie opcji Kompiluj z menu dost¦p-\nnego po naci±ni¦ciu prawego przycisku myszy na oknie rozkazu.\nWykorzystanie skompilowanego rozkazu najcz¦±ciej odbywa si¦ poprzez u»ycie go i wykonanie w pro-\ngramie, napisanym w j¦zyku asemblera Maszyny W, czyli zestawie tego typu rozkazów [6].\n138\nR. Brzeski\nAby móc u»y¢, uruchomi¢ napisany rozkaz, musi on by¢ dost¦pny na li±cie rozkazów Maszyny W,\nmenu: Widok →Lista rozkazów. Aby skompilowany rozkaz znalazª si¦ na tej li±cie, musz¡ by¢ zmienione\ndomy±lne ustawienia, w menu: Projekt →Opcje →Liczba bitów kodu - trzeba zmieni¢ warto±¢ z trzy\nna cztery. Na trzech bitach mo»na zakodowa¢ 8 warto±ci, czyli tyle ile jest ju» w Maszynie W rozkazów\nprede\u001cniowanych. Na czterech bitach mo»na zakodowa¢ 16 ró»nych warto±ci, które b¦d¡ reprezentowa¢\nkody poszczególnych rozkazów - w ten sposób do symulatora Maszyny W, mo»na doda¢ 8 kolejnych\nrozkazów.\nW trakcie kompilowania rozkazów zostanie zrealizowana wst¦pna kontrola skªadniowa zaimplemen-\ntowanego rozkazu. Je»eli kompilator znajdzie bª¡d, to uzyskamy odpowiedni komunikat zwrotny. Je»eli\nkompilator b¦dzie w stanie skompilowa¢ rozkaz, to zostanie on dodany do listy dost¦pnych rozkazów:\nWidok →Lista rozkazów.\nW ramach laboratorium student b¦dzie miaª mo»liwo±¢ wdro»enia wiedzy teoretycznej w czasie imple-\nmentacji zadanych rozkazów asemblerowych. Tre±¢ zada« do wykonania b¦dzie przedstawiona w postaci\nopisu sªownego lub w formie skróconej przy u»yciu: nazw rejestrów (reprezentowanych przez skróty li-\nterowe), nawiasów, wykonywanych operacji lub warunków i wykonywanego przesyªu (przesyªu warto±ci\npomi¦dzy rejestrami lub pami¦ci¡). Przesyª reprezentowany przez znak `→' oznacza, »e warto±¢ uzyskana\npo lewej stronie →jest przesyªana w miejsce wskazywane po prawej stronie →. Skróty literowe ozna-\nczaj¡ poszczególne rejestry. W najprostszej sytuacji np.: (A) →B oznacza, »e warto±¢ rejestru A nale»y\nprzesªa¢ do rejestru B [6].\nWa»ne jest, aby utworzony rozkaz nie tylko dziaªaª prawidªowo, czyli realizowaª postawione przed\nnim zadanie i byª mo»liwy do u»ycia w programie, ale tak»e wa»ne jest, aby byª optymalny, czyli byª\nwykonywany w najmniejszej mo»liwej liczbie taktów (cyklów) procesora.\nPodobnie jak w poprzednim artykule [6], tak i w tym zakªada si¦, »e czytelnik posiada podstawow¡\nwiedz¦ teoretyczn¡ na temat Maszyny W [1\u00156] i poprzez bie»¡cy artykuª chce poszerzy¢ j¡ o elementy\npraktycznych podpowiedzi i dodatkowych wyja±nie« z zakresu implementacji rozkazów. Pami¦ta¢ tak»e\nnale»y, »e jedynie samodzielna realizacja zada« pozwala w peªni zrozumie¢ zale»no±ci pomi¦dzy elemen-\ntami tematyki zwi¡zanej z Maszyn¡ W. Kopiowanie rozwi¡za« od `s¡siada' nie skutkuje kopiowaniem\numiej¦tno±ci ani wiedzy, a co najwy»ej kopiowaniem bª¦dów tam istniej¡cych. Artykuª ten jest efektem\nkilkunastoletnich do±wiadcze« autora w prowadzeniu zaj¦¢ z Podstaw Informatyki, a przedstawione w\nrozdziale 2 nieprawidªowo±ci w trakcie tworzenia rozkazów, s¡ oparte na faktycznie popeªnianych przez\nstudentów bª¦dach.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Przykªady bª¦dów przy implementacji rozkazów\nW bie»¡cym rozdziale zostan¡ zaprezentowane przykªady implementacji nieprawidªowych, wraz z ich\nomówieniem oraz przedstawieniem rozwi¡zania prawidªowego.\n2.1. Bª¡d zwi¡zany z brakiem zrozumienia liczby nawiasów wokóª rejestru.\nOmówienie zagadnienia:\nNawiasy wyst¦puj¡ wokóª skrótów literowych rejestru. Liczba nawiasów ma kluczowe znaczenie. Ina-\nczej jest rozumiana po lewej, a inaczej po prawej stronie przesyªu. Wyja±nienie liczby nawiasów przed-\nstawione jest na przykªadowym rejestrze o nazwie R [6]:\nW zale»no±ci od liczby nawiasów po lewej stronie przesyªu:\nPrawidªowe tworzenie rozkazów asemblerowych dla Maszyny W cz.2\n139\n(R) \u0015 oznacza warto±¢ znajduj¡c¡ si¦ w rejestrze R.\n((R)) \u0015 oznacza warto±¢ znajduj¡c¡ si¦ w pami¦ci o adresie wskazywanym przez rejestr R.\n(((R))) \u0015 oznacza, »e warto±¢ rejestru R jest adresem (wska¹nikiem) do komórki pami¦ci, którego\nwarto±¢ ponownie jest wska¹nikiem do pami¦ci, spod którego nale»y odczyta¢ (pobra¢) warto±¢.\nNatomiast po prawej stronie przesyªu:\n(R) - oznacza, »e uzyskan¡ wcze±niej warto±¢, nale»y zapisa¢ do pami¦ci o adresie wskazywanym przez\nrejestr R (adresie umieszczonym w rejestrze R).\n((R)) - oznacza, »e warto±¢ rejestru R jest adresem (wska¹nikiem) do komórki pami¦ci, którego warto±¢\nponownie jest wska¹nikiem do pami¦ci, pod który nale»y zapisa¢ warto±¢ `operacji' uzyskan¡ z lewej\nstrony przesyªu `→'.\nBª¦dny przykªad 1.1 (Warto±¢ rejestru akumulatora doda¢ do warto±ci komórki pami¦ci o adresie\nznajduj¡cym si¦ w rejestrze AD, wynik dodawania pozostawi¢ w rejestrze akumulatora):\n// ((AD)) + (AK) →AK\nROZKAZ JJ-J;\nczyt wys wei il;\nwyad sa weja dod weak; // bª¡d - AD jest w dwóch nawiasach, a nie w jednym\nwyl wea;\nW tym bª¦dnym przykªadzie, niezgodnie z tre±ci¡ zadania, do akumulatora dodawana jest warto±¢\nprzechowywana w rejestrze AD. Zgodnie z tre±ci¡ zadania, symbol rejestru AD jest w dwóch nawiasach,\nwi¦c w rejestrze AD jest adres komórki pami¦ci, w której znajduje si¦ warto±¢, któr¡ to nale»y doda¢\ndo akumulatora. Dlatego w prawidªowym rozwi¡zaniu, warto±¢ rejestru AD najpierw przesyªana jest\ndo rejestru A (wyad wea), w kolejnym takcie jest odczytywana (sygnaª czyt) warto±¢ komórki pami¦ci\n(o adresie umieszczonym w rejestrze A), co powoduje umieszczenie tej warto±ci w rejestrze S, i nast¦pnie\nprzesyªana jest do jednostki arytmetyczno logicznej (wys weja) i dodawana do warto±ci akumulatora (dod\nweak).\nPrawidªowe rozwi¡zanie 1.1:\n// ((AD)) + (AK) →AK\nROZKAZ JJ-J;\nczyt wys wei il;\nwyad wea;\nczyt wys weja dod weak wyl wea;\nGdyby symbol rejestru AD byª w trzech nawiasach, to dodatkowo nale»aªoby przesªa¢ odczytan¡\nwarto±¢ z pami¦ci do rejestru A (wys sa wea) i w kolejnym takcie ponownie odczyta¢ (czyt) warto±¢\nz pami¦ci.\n140\nR. Brzeski\nPrawidªowe rozwi¡zanie 1.2 (Warto±¢ rejestru akumulatora doda¢ do warto±ci komórki pami¦ci\no adresie znajduj¡cym si¦ w komórce pami¦ci o adresie znajduj¡cym si¦ w rejestrze AD, wynik dodawania\npozostawi¢ w rejestrze akumulatora):\n// (((AD))) + (AK) →AK\nROZKAZ JJ-D;\nczyt wys wei il;\nwyad wea;\nczyt wys sa wea; // dodatkowy takt realizuj¡cy `trzeci nawias'\nczyt wys weja dod weak wyl wea;\n2.2. Bª¡d zwi¡zany z niezrozumieniem lub zbytnim uproszczeniem tre±ci za-\ndania.\nOmówienie zagadnienia: Czasami zdarza si¦, »e student bª¦dnie zrozumie lub nieodpowiednio\nupro±ci tre±¢ zadania. Zadanie do wykonania trzeba odpowiednio przeanalizowa¢ przed jego wykona-\nniem. Powinno si¦ najpierw znale¹¢ algorytm realizuj¡cy potrzebne czynno±ci i wtedy dopiero przej±¢ do\nimplementacji rozkazu. Przy analizie zadania nale»y wzi¡¢ pod uwag¦, »e warto±ci rejestrów które trzeba\nw zadaniu uwzgl¦dni¢ s¡ z momentu rozpocz¦cia wykonywania rozkazu, natomiast dost¦p do warto±ci\nrejestrów, uzyskuje si¦ dopiero po wykonaniu pierwszego taktu. Ten pierwszy takt jest standardowy dla\nka»dego rozkazu i nie mo»na go zmieni¢ (ani nie mo»na doda¢ kolejnych mikrosygnaªów, ani nie mo»na\nusun¡¢ którego±).\nBª¦dny przykªad 2.1 (Warto±¢ rejestru AK doda¢ do warto±ci rejestru L, wynik dodawania pozo-\nstawi¢ w rejestrze akumulatora oraz przesªa¢ do rejestru licznika):\n// (L) + (AK) →AK, L\nROZKAZ JD-J;\nczyt wys wei il; // w tym takcie warto±¢ licznika zostaje zmieniona \u0015 zwi¦kszona o 1\nwyl sa weja dod weak; // bª¡d - dodawana jest ju» zmieniona warto±¢ licznika\nwyak sa wel wea;\nW zwi¡zku z tym, »e warto±¢ licznika ju» zostaªa w pierwszym takcie zmieniona \u0015 zwi¦kszona o 1,\nto w drugim takcie dodawana jest ju» ta zinkrementowana o 1 warto±¢ licznika, a nie ta która byªa tam\nw momencie rozpocz¦cia wykonywania rozkazu. Dlatego wynik ko«cowy jest bª¦dny \u0015 jest zwi¦kszony\no jeden. W zwi¡zku z tym, »e nie ma bezpo±redniego dost¦pu do warto±ci pocz¡tkowej licznika, to uzyskany\nwynik dodawania, aby byª prawidªowy, nale»y zdekrementowa¢ o warto±¢ jeden. Mo»na to zrobi¢ u»ywaj¡c\nmo»liwo±ci inkrementacji licznika (sygnaªem il) w ten sposób, »e do akumulatora zostanie dodana bie»¡ca\nwarto±¢ rejestru L (wyl sa weja dod weak) a nast¦pnie, po inkrementacji warto±ci licznika, jego warto±¢\nzostanie odj¦ta od akumulatora (wyl sa weja ode weak). W ten sposób pierwotna warto±¢ akumulatora\nzostanie zmniejszona wªa±nie o warto±¢ 1: (AK) + (L) - [(L)+1] = (AK) \u0015 1.\nPrawidªowe tworzenie rozkazów asemblerowych dla Maszyny W cz.2\n141\nPrawidªowe rozwi¡zanie 2.1:\n// (L) + (AK) →AK, L\nROZKAZ JD-J;\nczyt wys wei il;\nwyl sa weja dod weak;\nwyl sa weja dod weak il;\nwyl sa weja ode weak;\nwyak sa wel wea;\nWarto tu jednak podkre±li¢ i zapami¦ta¢, »e w ogólno±ci nie mo»na w dowolny sposób zmienia¢\nzawarto±ci licznika podczas implementacji rozkazu. Je»eli jest to robione, to najcz¦±ciej nale»y zapami¦ta¢\njego warto±¢ pierwotn¡ (po inkrementacji w pierwszym takcie), tak aby mo»na go byªo odtworzy¢. Jednak\nw tym przypadku nie jest to konieczne, gdy» jest to rozkaz skoku, w którym to w sposób ±wiadomy\nmody\u001ckujemy warto±¢ licznika, zatem nie ma tu potrzeby zapami¦tywania (i odtwarzania) jego pierwotnej\nwarto±ci.\n2.3. Bª¡d zwi¡zany z myleniem rejestru AD z rejestrem A.\nOmówienie zagadnienia:\nCz¦±¢ adresowa rejestru instrukcji reprezentowana symbolem AD cz¦sto jest mylona z rejestrem A.\nOdczyta¢ warto±¢ z rejestru AD mo»na sygnaªem wyad, który udost¦pnia t¦ warto±¢ na magistrali adre-\nsowej i z niej mo»na przesªa¢ j¡ dalej, zgodnie z tre±ci¡ zadania i implementowanym algorytmem.\nBª¦dny przykªad 3.1 (Warto±¢ rejestru akumulatora doda¢ do warto±ci komórki pami¦ci o adresie\nznajduj¡cym si¦ w rejestrze AD, wynik dodawania pozostawi¢ w rejestrze akumulatora):\n// ((AD)) + (AK) →AK\nROZKAZ JT-J;\nczyt wys wei il;\nczyt wys weja dod weak wyl wea;//bª¡d- do rejestru A najpierw nale»y przesªa¢ warto±¢ rejestru AD\nPrawidªowe rozwi¡zanie 3.1:\n// if (AK) < (AD) then (L)+3 →L else (L)+1 →L\n// ((AD)) + (AK) →AK\nROZKAZ JT-J\nczyt wys wei il;\nwyad wea;\nczyt wys weja dod weak wyl wea;\n2.4. Bª¡d zwi¡zany z nieuprawnionym korzystaniem z pami¦ci.\nOmówienie zagadnienia:\nKorzystanie z pami¦ci, czyli odczytywanie lub zapisywanie warto±ci pod jaki± adres, mo»e odbywa¢\nsi¦ tylko wtedy, gdy jest to jawnie okre±lone w tre±ci zadania. Dodatkowo tego typu operacje mog¡ by¢\n142\nR. Brzeski\nrealizowane tylko na tych adresach, które zostaªy wskazane w tre±ci zadania. Aby nie generowa¢ niepo-\ntrzebnych bª¦dów w zakresie rozumienia operacji na pami¦ci, potrzebne jest rozumienie liczby nawiasów\nwokóª rejestru, omówione w rozdziale 2.1. Pami¦ta¢ nale»y, »e przy tworzeniu algorytmu dla otrzyma-\nnego zadania, nie mo»na samowolnie zapisywa¢ warto±ci pod jakikolwiek adres w pami¦ci. Pod ka»dym\nadresem w pami¦ci mo»e znajdowa¢ si¦ inny kod rozkazu lub zmienna wykorzystywana programie.\nBª¦dny przykªad 4.1 (Od warto±ci komórki pami¦ci o adresie znajduj¡cym si¦ w rejestrze AD odj¡¢\nwarto±¢ rejestru akumulatora, wynik pozostawi¢ w rejestrze akumulatora):\n// ((AD)) - (AK) →AK\nROZKAZ JC-J;\nczyt wys wei il;\nwyl wea wyak wes;\npisz; // bª¡d - nieuprawniony zapis do pami¦ci\nwyad wea;\nczyt wys weja przep weak;\nwyl wea;\nczyt wys weja ode weak;\nW tym nieprawidªowym przykªadzie, warto±¢ akumulatora zostaªa zapisana do komórki pami¦ci, o ad-\nresie znajduj¡cym si¦ w liczniku, aby zapami¦ta¢ warto±¢ akumulatora, któr¡ student planuje odj¡¢ od\nwpisanej najpierw do AK (niszcz¡c pierwotn¡ jego warto±¢) warto±ci komórki pami¦ci o adresie znajdu-\nj¡cym si¦ w rejestrze AD. Niestety, zapisuj¡c w pami¦ci (pod adres znajduj¡cy si¦ w liczniku) pierwotn¡\nwarto±¢ AK, kod programu znajduj¡cy si¦ w tej komórce pami¦ci (domy±lnie nast¦pny rozkaz) zostaª\nnadpisany/zniszczony. W zwi¡zku z tym nie b¦dzie mo»liwo±ci wykonania rozkazu nast¦pnego po bie»¡-\ncym, a maszyna W jako nast¦pny b¦dzie realizowaªa rozkaz, b¦d¡cy interpretacj¡ liczby - pocz¡tkowej\nwarto±ci akumulatora sprzed wykonania bª¦dnie zrealizowanego rozkazu JC-J.\nW prawidªowym rozwi¡zaniu najpierw uzyskiwana jest ujemna warto±¢ akumulatora, a dopiero wtedy\ndodawana jest do niego warto±¢ komórki pami¦ci, o adresie zawartym w rejestrze AD. W takim przypadku\nnie ma potrzeby zapisywania w pami¦ci pierwotnej warto±ci akumulatora.\nPrawidªowe rozwi¡zanie 4.1:\n// ((AD)) - (AK) →AK\nROZKAZ JC-J;\nczyt wys wei il;\nwyak wes weja ode weak; // zapisanie warto±ci AK do rejestru S i jednoczesne zerowanie AK\nwys weja ode weak wyad wea; // odj¦cie od wyzerowanego akumulatora wcze±niejszej jego warto±ci\nczyt wys weja dod weak wyl wea;\nPrawidªowe tworzenie rozkazów asemblerowych dla Maszyny W cz.2\n143\nBª¦dny przykªad 4.2 (Od warto±ci rejestru AD odj¡¢ jeden. Wynik nale»y umie±ci¢ w rejestrze\nakumulatora):\nUwaga napisana przez studenta do poni»szego bª¦dnego rozkazu: `pod adresem 1 musi by¢ warto±¢\n1'. Takie zaªo»enie jest nieuprawnione, nie mo»na zakªada¢, »e pod jakim± adresem w pami¦ci b¦dzie\nprzydatna w algorytmie warto±¢.\n// (AD) - 1 →AK\nROZKAZ JC-D;\nczyt wys wei il;\nwyad sa weja przep weak;\nwyl wea;\nczyt wys weja ode weak;\nwyl wea;\nW tym nieprawidªowym rozwi¡zaniu student nie tylko w sposób nieuprawniony korzysta z pami¦ci,\nale jednocze±nie zakªada, »e warto±¢ licznika b¦dzie równa jeden, co b¦dzie prawd¡ jedynie dla pierwszego\nrozkazu umieszczonego w caªym programie.\nW prawidªowym rozwi¡zaniu wynik jest dekrementowany o warto±¢ 1 przy u»yciu licznika, podobnie\njak w przykªadzie 2.1. Dodatkowo warto±¢ licznika jest zachowywana w rejestrze S, gdy» w tym rozkazie\nnie mo»e ona ulec utraceniu i na ko«cu trzeba t¦ warto±¢ przywróci¢ (wys sa wel).\nPrawidªowe rozwi¡zanie 4.2:\n// (AD) - 1 →AK\nROZKAZ JC-D;\nczyt wys wei il;\nwyad sa weja przep weak;\nwyl sa weja dod weak wea wes il;\nwyl sa weja ode weak;\nwys sa wel;\n2.5. Bª¡d zwi¡zany z nieprawidªowym wyborem architektury Maszyny W.\nOmówienie zagadnienia:\nMaszyna W, poprzez dodawanie do niej kolejnych komponentów, umo»liwia zmian¦ swojej architek-\ntury. Najbardziej podstawowa to architektura W oraz W+ (zawieraj¡ca dodatkowo poª¡czenie mi¦dzy\nmagistral¡ danych i adresow¡). Zadania do realizacji zazwyczaj ustalane s¡ na konkretn¡ architektur¦\ni samowolnie nie mo»na u»ywa¢ elementów dodatkowych, zawartych w innej architekturze. Oczywi±cie\nzada« typowych dla architektury W+ nie da si¦ wykona¢ na architekturze W. Je»eli jawnie nie jest po-\ndane, na jak¡ architektur¦ nale»y zaimplementowa¢ rozkaz, to mo»na powiedzie¢, »e zadanie powinno si¦\nwykona¢, w na tyle prostej architekturze na ile to mo»liwe.\nBª¦dny przykªad 5.1: (Warto±¢ rejestru akumulatora doda¢ do warto±ci komórki pami¦ci o adresie\nznajduj¡cym si¦ w rejestrze AK, wynik dodawania pozostawi¢ w rejestrze akumulatora):\n144\nR. Brzeski\n// (AK) + ((AK)) →AK\ntego zadania nie da si¦ zrealizowa¢ na architekturze W\nROZKAZ JP-J;\nczyt wys wei il;\nwyak wei; // bª¡d opisany w artykule [6]\nwyad wea;\nczyt wys weja weak dod wyl wea;\nPrawidªowe rozwi¡zanie 5.1:\n// (AK) + ((AK)) →AK\nDo realizacji tego zadania trzeba wykorzysta¢ architektur¦ W+\nROZKAZ JP-J;\nczyt wys wei il;\nwyak sa wea; // warto±¢ przesyªana jest przez dodatkowe poª¡czenie mi¦dzymagistralowe\nczyt wys weja weak dod wyl wea;\nBª¦dny przykªad 5.2 (Od warto±ci komórki pami¦ci o adresie znajduj¡cym si¦ w rejestrze L odj¡¢\nwarto±¢ rejestru akumulatora, wynik pozostawi¢ w rejestrze akumulatora):\n// ((L)) - (AK) →AK\nDo tego zadania nie trzeba W+, wystarczy W\nROZKAZ JP-D;\nczyt wys wei il;\nwyl wea;\nwyak sa wel;\nczyt wys weja przep weak;\nwyl sa weja weak ode weak wyl wea;\nW tym bª¦dnym przykªadzie poprzez przesªanie akumulatora do licznika, nast¦puje utrata jego war-\nto±ci - bª¡d opisany w artykule [6]. Dodatkowo w ostatnim takcie wyst¦puje podwójnie sygnaª wyl -\nw obecnie u»ywanym symulatorze Maszyny W nie generuje to »adnego bª¦du (symulator traktuje to jak\npojedyncze wywoªanie sygnaªu wyl), jednak kolejne wypisanie w tym samym takcie tego samego sygnaªu\njest nadmiarowe i nie powinno mie¢ miejsca.\nPrawidªowe rozwi¡zanie 5.2:\n// ((L)) - (AK) →AK\nROZKAZ JP-D;\nczyt wys wei il;\nwyl wea wyak weja ode weak wes;\nwys weja ode weak;\nczyt wys weja dod weak;\nDla rozwi¡zania prawidªowego, dodatkowo warto zwróci¢ uwag¦ na brak w ostatnim takcie sygnaªów\nwyl wea. W tym rozkazie przesªanie warto±ci licznika do rejestru adresowego zostaªo ju» zrealizowane\nw drugim takcie.\nPrawidªowe tworzenie rozkazów asemblerowych dla Maszyny W cz.2\n145\n2.6. Bª¡d zwi¡zany z zamian¡ ±cie»ek instrukcji `JE»ELI'.\nOmówienie zagadnienia:\nWarunkowa instrukcja JE»ELI zawiera dwie alternatywne ±cie»ki rozwi¡za«. Czasami zdarza si¦ po-\nmyªka interpretacji, która ±cie»ka kiedy jest wykonywana (przy speªnieniu którego warunku). Dotyczy\nto zarówno sprawdzania sygnaªu Z (warto±¢ ujemna lub nieujemna) jak i sygnaªu ZAK (warto±¢ zero\nlub nie zero). Przy tego typu zadaniach nale»y upewni¢ si¦, czy przy danym warunku, wykonywana jest\nodpowiednia ±cie»ka operacji.\nBª¦dny przykªad 6.1 (Mniejsz¡ z dwóch warto±ci nale»y umie±ci¢ w rejestrze akumulatora. Pierwsza\nz tych dwóch warto±ci znajduje si¦ w rejestrze AK, natomiast druga warto±¢ w rejestrze AD):\n// min{ (AK), (AD) } →AK\nROZKAZ JS-J;\nczyt wys wei il;\nwyad sa wes weja ode weak\nJE»ELI z TO @wieksza GDY NIE @mniejsza;\n@wieksza wys weja przep weak wyl wea KONIEC; // bª¡d\n@mniejsza wys weja dod weak wyl wea; // bª¡d\nW tym bª¦dnym przykªadzie operacje przepisania (przep) oraz dodawania (dod) s¡ wykonane przy\nodwrotnych warunkach, w trakcie innej - tej drugiej ±cie»ki wykonania instrukcji JE»ELI. W wyniku\nczego zamiast rozkazu wyznaczaj¡cego minimum, otrzymamy rozkaz wyznaczaj¡cy maksimum.\nW rozwi¡zaniu prawidªowym, dziaªanie przepisania jest wykonane w ±cie»ce oznaczonej etykiet¡\n@mniejsza zamiast @wieksza, natomiast dziaªanie dodawania - odwrotnie.\nPrawidªowe rozwi¡zanie 6.1:\n// min{ (AK), (AD) } →AK\nROZKAZ JS-J;\nczyt wys wei il;\nwyad sa wes weja ode weak\nJE»ELI z TO @wieksza GDY NIE @mniejsza;\n@wieksza wys weja dod weak wyl wea KONIEC;\n@mniejsza wys weja przep weak wyl wea;\nBª¦dny przykªad 6.2 (Je»eli warto±¢ znajduj¡ca si¦ w akumulatorze jest równa zero, wtedy po-\ncz¡tkow¡ warto±¢ licznika nale»y zwi¦kszy¢ o warto±¢ trzy, w przeciwnej sytuacji warto±¢ licznika nale»y\nzwi¦kszy¢ o warto±¢ jeden):\n// if (AK) = 0 then (L) + 3 →L else (L) + 1 →L\nROZKAZ JS-D;\nczyt wys wei il;\nJE»ELI zak TO @jeden GDY NIE @trzy; // bª¡d\n@trzy il;\nil DALEJ @jeden;\n146\nR. Brzeski\n@jeden wyl wea;\nW tym bª¦dnym przykªadzie zamieniony zostaª warunek wykonania poszczególnych ±cie»ek instrukcji\nJE»ELI.\nW prawidªowym rozwi¡zaniu etykiety poszczególnych ±cie»ek przy instrukcji JE»ELI s¡ umieszczone\nodwrotnie, co spowoduje poprawne wykonanie tego rozkazu: gdy warto±¢ znajduj¡ca si¦ w akumula-\ntorze jest równa zero, nale»y pomin¡¢ realizacj¦ dwóch nast¦pnych rozkazów zapisanych w programie,\na w przeciwnej sytuacji przej±¢ do realizacji kolejnego rozkazu programu.\nPrawidªowe rozwi¡zanie 6.2:\n// if (AK) = 0 then (L) + 3 →L else (L) + 1 →L\nROZKAZ JS-D;\nczyt wys wei il;\nJE»ELI zak TO @trzy GDY NIE @jeden;\n@trzy il;\nil DALEJ @jeden;\n@jeden wyl wea;\n2.7. Bª¡d zwi¡zany z prób¡ umieszczania w liczniku warto±ci ujemnej.\nOmówienie zagadnienia:\nW zwi¡zku ze sposobem zapisu liczb ujemnych w trybie dopeªnieniowym do 2, stosowanym typowo\nw maszynach cyfrowych, w liczniku nie mo»na przechowywa¢ warto±ci ujemnych. W Maszynie W przesªa-\nnie warto±ci ujemnej do licznika, powoduje uzyskanie w liczniku innej warto±ci dodatniej. Zdecydowanie\nnie nale»y wykonywa¢ takiej operacji.\nBª¦dny przykªad 7.1 (Podwójn¡ warto±¢ rejestru AD zdekrementowa¢ o jeden i taki wynik umie±ci¢\nw liczniku. Dodatkowe zaªo»enie: warto±¢ akumulatora nie musi by¢ zachowana):\n// 2*(AD) - 1 →L\nROZKAZ JSI-J;\nczyt wys wei il;\nwyl sa weja przep weak il;\nwyl sa weja ode weak;\nwyak sa wel; // bª¡d - w tym momencie nast¡pi zmiana warto±ci z minus 1 na warto±¢\n// maksymaln¡ dodatni¡ mo»liw¡ do przechowania w liczniku\nwyad sa weja przep weak;\nwyak weja dod weak;\nwyl was weja ode weak;\nwyak sa wel wea;\nW bª¦dnym przykªadzie niepotrzebnie utworzono warto±¢ minus jeden. Warto±¢ ta w akumulatorze\nkodowana jest standardowo na 8 bitach, natomiast po przesªaniu jej do licznika (poprzez magistral¦\nadresow¡, która jest w¦»sza od magistrali danych) otrzymujemy standardowo warto±¢ 5-bitow¡ z obci¦tymi\nPrawidªowe tworzenie rozkazów asemblerowych dla Maszyny W cz.2\n147\ntrzema najbardziej znacz¡cymi bitami. Zagadnienie problemu przesyªów mi¦dzy magistralami Maszyny\nW i utrata bitów jest dokªadniej opisana w [2] (str.6-7).\nW prawidªowym rozwi¡zaniu najpierw uzyskano podwojon¡ warto±¢ rejestru AD, a dopiero w nast¦p-\nnym kroku zmniejszono t¦ warto±¢ o jeden. Zmniejszenie warto±ci o jeden zrealizowano analogicznie jak\nw przykªadzie 4.2\nPrawidªowe rozwi¡zanie 7.1:\n// 2*(AD) - 1 →L\nROZKAZ JSI-J;\nczyt wys wei il;\nwyad sa weja przep weak;\nwyak weja dod weak;\nwyl sa weja dod weak il;\nwyl sa weja ode weak;\nwyak sa wel wea;",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. Wnioski ko«cowe\nRealizuj¡c zadanie utworzenia rozkazu, czyli znalezienia odpowiedniego algorytmu i jego implementa-\ncji, mo»na popeªni¢ wiele ró»nych bª¦dów. Wynikaj¡ one najcz¦±ciej z braku jakiego± elementu wiedzy, ale\nczasami tak»e s¡ skutkiem zastosowania nieodpowiedniego algorytmu lub zwykªej pomyªki. Aby uªatwi¢,\nzarówno unikanie tych bª¦dów jak i znalezienie prawidªowych rozwi¡za«, mo»na utworzy¢ list¦ bª¦dów\nmaj¡cych miejsce podczas tworzenia rozkazu:",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Brak zrozumienia liczby nawiasów wokóª rejestru - nale»y w peªni rozumie¢ zapis tre±ci rozkazu\nw postaci nawiasowej.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Niezrozumienie lub zbytnie uproszczenie tre±ci zadania - nale»y dokªadnie przeczyta¢ i przeanali-\nzowa¢ tre±¢ zadania.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. Nieuprawnione korzystanie z pami¦ci (zapis, odczyt) - je»eli w tre±ci zadania nie ma takiego pole-\ncenia, to nie mo»na korzysta¢ z pami¦ci.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "5. Nieprawidªowy wybór architektury Maszyny W - zadania nale»y wykona¢ na takiej architektu-\nrze na jak¡ zostaªo to zlecone. Je»eli nie ma jawnej informacji o wyborze architektury, to nale»y\nzaimplementowa¢ rozkaz w na tyle prostej architekturze na ile to mo»liwe.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. Zamiana ±cie»ek instrukcji `JE»ELI' - nale»y upewni¢ si¦, czy przy danym warunku, wykonywana\njest odpowiednia ±cie»ka operacji.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "7. Bª¡d zwi¡zany z przesyªaniem do licznika warto±ci ujemnej - w liczniku nie mo»na umieszcza¢\nwarto±ci ujemnych.\n148\nR. Brzeski\nArtykuª ten, w szczególno±ci dla studentów, mo»e by¢ nie tylko materiaªem pomocnym przy realizacji\notrzymanych zada« i rozwi¡zywaniu potencjalnych problemów, ale tak»e, przy odpowiednim opanowaniu\nzawartych tu wskazówek, pozwala tych problemów unikn¡¢. Stanowi tak»e dobre narz¦dzie dla studentów\ndo sprawdzenia stopnia opanowania umiej¦tno±ci praktycznych i prawidªowej implementacji rozkazów.\nPodzi¦kowania\nAutor pragnie podzi¦kowa¢ recenzentom za trud wªo»ony w recenzje.\nLiteratura",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. A. Momot, R. Tutajewicz, Maszyna W - jak zaprojektowa¢ prosty rozkaz, MINUT 2019 (1), s. 24-35\nISSN 2719-3063.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. A. Momot, Projektowanie rozkazów dla maszyny W - konspekt ¢wicze« laboratoryjnych , MINUT\n2020 (2), s. 1-11 ISSN 2719-3063.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. M. Chªopek, R. Tutajewicz, Wykªady z Podstaw Informatyki profesora Stefana W¦grzyna, Skrypt\nuczelniany Politechniki l¡skiej nr 2062. Wydawnictwo Politechniki l¡skiej, Gliwice, 1997.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. K. Grochla, G. Hry«, S. Iwaszenko, P. Kasprzyk, J. Kubica, M. Widera, T. Wróbel, Wykªady z Pod-\nstaw Informatyki profesora Stefana W¦grzyna, Skrypt uczelniany Politechniki l¡skiej nr 2321. Wy-\ndawnictwo Politechniki l¡skiej, Gliwice, 2003.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. R. Brzeski, Prawidªowe tworzenie rozkazów asemblerowych dla Maszyny W cz.1, MINUT 2020 (2),\ns. 124-135 ISSN 2719-3063.",
    "source": "C-20-008.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "Faculty of Automatic Control, Electronics and Computer Science\nInformatics, 1st cycle of higher education, semester 1\nProgramming in assembler language\nProgramming in assembler language is not much different from programming in high-level \nlanguages. The main difference is the need to use a much poorer set of instructions. In assembler \nlanguages, for example, there are no structural instructions or instructions that allow you to \neasily describe the calculation of an arithmetic expression. However, anything you can write in \nhigh-level languages can certainly be expressed using assembler instructions. You can also do \nmany things that are impossible to easily formulate in high-level languages. A programmer \nwriting in assembler language has full control over what is happening during calculations in the \nprocessor. It is also not limited by various rules in high-level languages. However, full control \nand no restrictions mean also full responsibility for the written program.\nWhen writing a program in assembler language, we use almost exclusively the instructions \ncorresponding to the instructions of a given processor. Therefore, it is necessary to know these \ninstructions, as well as familiarize yourself with the architecture of the processor. The assembler \nlanguage program consists of instructions and data on which these instructions operate. The \nprogram is a sequence of successive lines, in each line there may be one instruction statement \nor a single data declaration. Formally, the syntax of the program line is as follows:\n[<label>:] <statement> [<argument>]\nwhere:\n <label> – a string of letters and numbers that is a symbolic representation of the\nspecified address \n <statement> – symbolic name (mnemonics) of one of the processor's\ninstructions or one of the so-called pseudo-instruction (declaration of space in \nmemory for data: RST, RPA) \n <argument> – a decimal number or one of the labels entered at the beginning of\nthe lines\nThe RST and RPA pseudo instructions allow you to appropriately reserve a memory location \nfor a single data with the initial value (RST) given as an argument and to reserve a place in \nmemory for the data without indicating its initial value (RPA). As the instruction statement, the \nname of one of the available instructions may appear. We will assume that there are 8 \ninstructions in the machine's W processor listed in the table 1.\n1\nTable 1. Instruction list\nMnemonic \nOpcode \nOperation \nSTP \n000 \nStop (end) the execution of the program \nDOD \n001 \nAdding to the accumulator AK the contents of the \nmemory location indicated by the argument \nODE \n010 \nsubtracting from the accumulator the contents of the \nmemory location indicated by the argument \nPOB \n011 \nretrieving the contents of the memory location indicated \nby the argument to the accumulator \nŁAD \n100 \nloading the contents of the accumulator to the memory \nlocation indicated by the argument \nSOB \n101 \nindication that the next instruction to execute will be the \none that is in the memory location indicated by the \nargument (unconditional jump) \nSOM \n110 \nIf there is a negative number in the accumulator, the next \ninstruction will be executed in the memory location \nindicated by the argument. If there is a non-negative \nnumber in the accumulator, the next instruction will be \ncarried out in memory directly after the SOM instruction \nSOZ \n111 \nThe jump to the address indicated by the argument is \nexecuted only when the accumulator is 0. Otherwise the \ninstruction placed in the memory immediately after the \nSOZ instruction will be performed as the next one.\nTo write a program in assembler language you must first create an algorithm that solves a \nspecific task, specify it using only available instructions and finally save it in the form of a \nprogram in assembler language. Writing these types of programs will be illustrated by several \nexamples.\nExample 1  \nWrite a program calculating the product of two natural numbers a and b and placing the result \nin the variable labeled c.\nThe first step in solving this task is to come up with the right algorithm. To find the product of \ntwo natural numbers a and b, it is enough at the very beginning to assume that it is equal to 0, \nand then a ties increase its value by b. This is illustrated in the block diagram in the figure 1\n2\nFigure 1. Multiplication algorithm\nBelow is a listing of the appropriate program in a situation where the variables a and b are equal \nto 4 and 5 respectively. Each operation on the diagram (figure 1) will usually correspond to one \nor more lines in the assembly language. Note that assigning the initial value of the variable c is \nnot represented by the sequence of machine instructions but it was implemented by using the \npseudo-instruction RST (line 14 in the code). Testing whether a takes a value of 0 implements \nthe code placed on lines 1 and 2. If the condition is met (a = 0), terminate the loop, retrieve the \nresult to the accumulator and terminate the program (lines 10 and 11).",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "Increasing the value of the variable c by the value of b is accomplished by the statements from \nlines 3, 4 and 5, while the decrementation of the variable a is in lines 6, 7 and 8. Note that the \nargument to the subtraction command (line 7) is not the number 1 (ODE 1 ) but the One label \npointing to a memory location containing one value (line 15). In our processor, the direct \naddressing mode is used, which means that the ODE 1 statement would be interpreted as a \ndesire to subtract from the accumulator the contents of the memory location with address 1, \nmeanwhile at this address the instruction in the second line of the program's code will be placed \nin memory. Finally, in line 9, the program returns to the beginning of the loop to test its \ntermination condition.\n3\nThe given program can be assembled (translated into machine code) and, after loading into the \nmain memory, executed. After its execution, the accumulator should have the final value of the \nvariable marked with the label c, in this case the value of 20.\nArray processing \nThe instructions listed in Table 1 allow you to express many even very complex programs \noperating on a variety of data. However, manipulating them with data that make up complex \nstructures is not a simple task. This requires the implementation of quite complicated \ntransformations that use knowledge about the location and organization of data in the \ncomputer's memory. This problem will be illustrated by an example.\nThe computer's memory has an n-element array. The first element of this array is stored in the \nmemory location marked with the Array label. For the memory location labeled Sum, enter the \nsum of all n elements in the array.\nBefore we present a solution to the task, let's explain how the elements of the array are arranged \nin memory. The array in the computer memory creates a coherent area, each subsequent element \nof the array is saved in the next location of this area. For example, a four-element array filled \nwith four consecutive natural numbers will be written in assembler language as follows:",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4.    \nRST 4\nKnowing the address of the first element of an array we can easily determine the location in the \nmemory (address) of any other element of the array. We will assume that the array, like in C, \nwill be indexed from 0. To enumerate the address in the memory of the third element of the \narray (that is, element with index 2), one should add the index of the corresponding element to \nthe address of the beginning of the array. If the array starts with a memory location with address \n20, the third element of this array can be found at address 22 (20 + 2 = 22).\nTo sum up all elements of an array, we will start by resetting the Sum variable. Next, we will \nadd to the variable Sum in the loop the values of subsequent elements starting from the first one, \nthat is, the one which is located under the symbolic address represented by the label Array. In \neach successive run of the loop, the value of the next element of the Array will be added, i.e. \nthe address of the added element after each loop run, we need to increase by 1. This type of task \nwould be easily performed using instructions with indirect or index addressing. Many \nprocessors offer such instructions. In the instruction list of our computer, however, we will not \nfind instructions using other addressing modes than direct addressing. Therefore, our solution \nwill require modifying the content of the program during its execution.\n4\n1. loop: \nPOB n",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "20. One: \nRST 1\nAfter each loop run, you must modify the contents of the instruction for adding another element \nof the array, so that the statement actually uses the address of the next element each time. Since \nthe elements of the array are stored one after the other in memory, it means that, as mentioned \nabove, we must increase the address of the element being added by 1 in each loop run. This task \nis carried out by statements placed on lines 8, 9 and 10. The accumulator receives from the \nmemory the instruction of adding another element of the array (line 6 in the program), \nincremented by 1 and re-written in the same place to the memory. Thanks to this, when this \ninstruction (from line 6) is executed again, its argument will be another element of the array. It \nshould be clearly stated that the modification from lines 8 - 10 only changes the content of the \ninstructions from line 6 and does not change the meaning of the Array label. If in the program \nin several instructions it would be necessary to refer to the next elements of the array in the \nsubsequent runs of the loop, all these instructions should be modified in a similar way.\nThe task of adding elements to an array can also be done a bit differently.\n5\n1. loop: \nPOB n",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "24. Addr: RST Array\nAnd in this case, further elements of the array are added in the loop, but the code modification \nis slightly different. This solution resembles a solution using pointers in C. The location marked \nwith the label Addr (line 24) contains the address of the beginning of the array (it is like an \npointer of this array). In each loop run, the value of the Array element indicated by the Addr \npointer (line 9) is added to the current Sum. The current value of the Addr location is added to \nthe POB 0 instruction code (line 23) and the result is saved in place marked with the Instr \n(line 9) label. In this way, we obtain the instruction adding to the accumulator the content of \nthe appropriate memory location, the address of which contains the Addr variable.\nI/O Operations \nPrevious programs have not exchanged information with the environment but only processed \nthe data initially stored in memory and saved it there (in memory). These programs would be \nmuch more general and would be more useful if the input could be entered from the keyboard \nand displayed on the screen. To make this possible, however, it is necessary to complete the list \nof instructions on the so-called input/output instructions.\nInput/output instructions\nTo ensure the exchange of information with the environment, at least two instructions must be \nadded: instruction for reading a single character from the input device (e.g. keyboard) and \ninstruction enabling the output of the accumulator content to the output device (e.g. screen).\n6\nThe arguments of both of these instructions will be the device number to which the instruction \napplies. We assume that the standard input device (keyboard) is marked with the number 1, and \nthe standard output device is marked with the number 2. The instruction for entering the \ncharacter will be called WPR. After entering, the code of the character is placed in the \naccumulator. The character output instruction (WYP) will print on the output device with the \ngiven number the character whose code is in the accumulator. Using these instructions, you can, \nfor example, write a program that copies characters entered on the keyboard to the output \ndevice. The program in the loop reads the character and writes it to the standard output. The \nsignal to terminate the program may be the reading of an appointment ending. With us such a \ncharacter will be a space. Below is the code for this program.\n1. loop: \nWPR 1",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "8. Space: RST 32\nTypically, computing programs do not need individual characters as input data, but numbers \nsaved as a sequence of digits. Also numerical results should be displayed as decimal digits. This \nmeans that it is necessary to convert the loaded strings of digits to the number and reverse \nconversion of the number written in binary to the appropriate sequence of decimal digits. It \nseems that it will be best if these tasks are implemented in the form of special subroutines.\nSubroutines \nUsing subroutines means you need to add more instructions to your processor. The subroutine \ncall (SDP) instruction, similar to a simple jump, causes the transition to execute the instruction \nwhose address is an argument to the SDP instruction. In addition, the content of the program \ncounter (so-called trace) is stored on the stack. By retaining the trace on the stack, it is possible \nto return to the next instruction after the SDP instruction at the moment when the subroutine \nwas completed. This return is carried out by the PWR instruction. In addition, we will introduce \ntwo more instructions related to the stack: DNS - placing the accumulator value on the top of \nthe stack and PZS removing the value from the top of the stack and storing it in the accumulator. \nThese instructions are often used to pass parameters between the calling program and the \nsubroutine. Below is a subroutine that calculates the square of a given number. The number \nwhose square we want to find should first be placed in the accumulator. Also in the accumulator \nthe subroutine will return the result.\n7",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "5.         SOZ zero  \n// when zero, you do not have to count  \n// anything (the result is zero), return",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "// first run of the loop \n7.         ŁAD Param  \n// needed when there was a negative number  \n// and its absolute value was calculated \n8. loop:   ODE One",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "9.         SOZ GoBack  \n// when the counter reaches zero, we finish \n10.        ŁAD Counter \n// when it's not over, you need to remember",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "18. Negat: ODE Param  \n// parameter with a negative number, so we \n// first calculate its absolute value",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "24. One:   RST 1\nThe main program (lines 1 and 2) has been simplified here to a maximum and is limited to \ncalling a subroutine that calculates the square of the number stored in the accumulator. The \ncontent of the subroutine starts on line 3. The parameter (the number whose square you want to \ncount) is in the accumulator. First, the subprogram checks what parameter value it has to deal \nwith. If it is zero, immediately go to the return instruction from the subroutine and the returned \nresult is 0. When the accumulator has a negative number, the opposite number is calculated (or \nif someone prefers the absolute value) and then proceed in the same way as for the positive \nnumber. In the case of a positive number, to determine its square, the number should be added \na certain number of times. This task implements a loop, the content of which was written in \nlines 8 to 15.\n8\nSubroutine of writing an integer on the output device\nThe task of writing a number placed in the accumulator on the output device can be done in the \nform of the Write subprogram with the code presented below.",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "36. Minus:   \nRST '-'\nThe list of instructions has been extended by instructions for multiplication (MNO) and division \n(DZI). The basic task of this procedure is to convert a binary number to a sequence of decimal \ndigits (represented as ASCII characters). This conversion was carried out using the stack. On \nthe stack, numbers are loaded one by one (stored with the use of ASCII code) being the next\n9\nresidues from division of the binary number by 10. To each residue the ASCII code \ncorresponding to the character 0 is added, thanks to which the conversion to the characters of \nthis code is made immediately. Numbers forming the form of numbers are therefore generated \nfrom the end. Thanks to the use of the stack, however, they will be output to the inverted, and \nthus correct, order. In the next step, the number is divided by 10 and the actions are repeated \nuntil the value reaches 0. Then from the stack we take the numbers one by one and print them \nout to the output device. To easily detect when the digits end, before they were written to the \nstack there was a so-called sentinel (here in the form of the number 0, see lines 4 and 5 in the \nsubprogram code). Picking a sentinel from the stack results in the ending of outputting digits to \nthe output and thus marks the end of the subroutine.\nSubprogram of entering numbers\nAlso when entering a number, the next characters (digits) are converted to the appropriate \nbinary form. This task is performed by the Read procedure. It reads subsequent digits forming \nthe form of a natural number and converts to a binary character until it reaches a sign other than \na digit. After completion, the loaded number is located in the accumulator. We leave the number \nentering code to the reader for independent analysis.",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Write a program calculating the greatest common divisor of two natural numbers placed\nin memory locations labeled A and B\n10",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Write a program calculating the lowest common multiple of two natural numbers placed\nin memory locations labeled A and B",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. Write a program calculating the product of two natural numbers placed in memory\nlocations labeled A and B",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. Write a program calculating the rest of the division of two natural numbers placed in\nmemory locations labeled A and B",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "5. There is an n-element array labeled Arr. Write a program to check how many times the\nvalue specified in the Pattern memory location appears in this array.",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. There is an n-element array labeled Arr. Write a program that changes the elements of\nthis array in pairs. Assume that n is an even number. For example, if in the array there \nwere consecutively the numbers 1 2 3 and 4, then after the program is to be 2 1 4 3.",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "7. There is an n-element array labeled Arr. Write a program that reverses the contents of\nthis array. For example, if the array was successively numbers 1 2 3 4 and 5, then after \nthe program is to be 5 4 3 2 1.",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "8. There is an n-element array labeled Arr. Write a program that finds the value of the\nlargest element of this array and inserts it into the memory location marked with the \nMax label.",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "9. There is an n-element array labeled Arr. Write a program that finds the value of the\nsmallest element in this array and inserts it into the memory location labeled Min.\nInput/output",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. Write a program that reads two natural numbers and prints the rest of the division of\nthese two numbers.",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "7. Write a program that reads a string from a standard input and writes only the numbers\nfrom this string to the standard output",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "8. Write a program that reads a string from a standard input and writes the string to the\nstandard output but with small letters converted into capitals",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "9. Write a program printing out the encrypted text read from the input. Use a one-\ndimensional affine code\nSubroutines",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Write a program calculating the factorial of a natural number using the subroutine\nexecuting the multiplication of integers.",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Write a program that calculates the power of two natural numbers using the subroutine\nexecuting the multiplication of integers.",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. Write a program calculating the value of the determinant computed from the elements\nof square matrix 2x2 using the subprogram executing the multiplication of integers.\n11",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. Write a program to check if a given number is a prime number using the sieve of\nEratosthenes method using a subprogram to find the remainder of the division of \nintegers\n12",
    "source": "Lab 4-6.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "Laboratorium Podstaw Informatyki\nLaboratorium nr 4 – Przerwania\n1 Wstęp \nIstnieją czasem takie sytuacje, w których należy przerwać dotychczasową pracę i wykonać coś, co \nw danej chwili jest ważniejsze. Po skończeniu, można dalej kontynuować dotychczasowe zajęcie – \nw momencie, w którym zostało ono przerwane.\nPodobna sytuacja występuje i w świecie komputerów. Wówczas to wykonujący się aktualnie program \nmoże zostać przerwany na skutek wystąpienia pewnego zjawiska, nazywanego zgłoszeniem \nprzerwania. Zgłaszający przerwanie (może to być człowiek naciskający przycisk, ale też np. inny układ \nelektroniczny) żąda, aby bieżące zadanie zostało przerwane, i co więcej – jego zgłoszenie zostało \nobsłużone jak najszybciej.\nFragment programu odpowiedzialny za obsługę przerwania nosi nazwę procedury obsługi przerwania. \nZazwyczaj, program podczas swojej regularnej pracy „nie dociera” do takiej procedury, a zostaje ona \nwywołana na skutek wystąpienia przerwania. Ważne jest, aby po skończeniu takiej procedury, \npowrócić w miejsce, w którym przerwania nastąpiło i być w stanie kontynuować dalszą pracę. Oznacza \nto konieczność zachowania bieżącego stanu procesora.\nCzasami występują sytuacje, w których nie można przerwać aktualnie wykonywanego programu, \nchociażby podczas konfiguracji układu przerwań. Co więcej, poszczególne przerwania (np. związane \nz różnymi przyciskami) mogą się różnić od siebie stopniem ważności – priorytetem. Wówczas należy w \npierwszej kolejności obsłużyć przerwanie ważniejsze, a dopiero później – te mniej ważne. Do aktywacji \ni dezaktywacji poszczególnych przerwań służy tzw. maska. Przerwanie może zostać zamaskowane, \noznacza to, że jego zgłoszenie jest jakby niewidoczne dla procesora.\n2 Układ przerwań maszyny W \nMaszyna W umożliwia obsługę przerwań za pomocą układu przerwań. Został on przedstawiony na \nrysunku poniżej (Rysunek 1).\nRysunek 1. Układ przerwań maszyny W\nSkłada się on z 4 podstawowych rejestrów:",
    "source": "Lab4-przerwania.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Rejestru zgłoszeń (RZ) – przechowującego informacje o zgłoszeniach, pochodzące z przycisków\numieszczonych ponad nim (oznaczonych numerami od 1 do 4).",
    "source": "Lab4-przerwania.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. Rejestru adresu procedury obsługi przerwania (AP) – przechowującego adres w pamięci, pod\nktórym znajduje się procedura obsługi przerwania.\nTrzy pierwsze rejestry (RZ, RM, RP) są 4 bitowe – służą one do przechowywania informacji \no przerwaniach, których w maszynie W dostępnych jest właśnie 4. Każdy bit takiego rejestru \nodpowiada poszczególnemu przerwaniu. Rejestr AP ma rozmiar równy szerokości magistrali adresowej \n– jego zadaniem jest właśnie przechowywanie adresu.\nZ punktu widzenia procesora, bezpośrednio dostępne dla niego są tylko 2 rejestry: RM i AP, bowiem \nistnieją sygnały sterujące umożliwiające ich odczyt (RM, AP) i zapis (tylko RM). Są to odpowiednio: \nwyrm, werm, wyap. Rejestr AP jest tylko do odczytu, bowiem znajduje się w nim adres procedury \nobsługi przerwania, który jest tam wpisywany przez układ przerwań, w momencie wystąpienie \ni przyjęcia zgłoszenia przerwania. Oba te rejestry podłączone są do magistrali adresowej.\nOprócz wspomnianych sygnałów sterujących związanych z wyżej wymienionymi rejestrami, układ \nprzerwań maszyny W udostępnia jeszcze 2:\n1. eni – (ang. enable interrupt) – aktywujący układ przerwań i nakazujący mu ustawienie\nodpowiednich wartości rejestrów: RP i AP, \n2. rint – (ang. reset interrupt) – resetujący układ przerwań – zerujący rejestry: RP i AP oraz\nodpowiedni bit rejestru RZ1.\n3 Proces przyjmowania przerwania \nProces od naciśnięcia przycisku, a więc od momentu zgłoszenia przerwania, do jego faktycznej obsługi, \nczyli przejścia programu do procedury obsługi przerwania, jest dość złożony i składa się z kilku faz. \nZostały one przedstawione poniżej. Na wszystkich rysunkach, wartości rejestrów 4 bitowych zostały \nprzedstawione w postaci binarnej – znacznie ułatwiającej ich interpretację.\n3.1 Zgłoszenie przerwania \nZgłoszenie przerwania w maszynie W następuje na skutek naciśnięcia przycisku (1 – 4). Wówczas to, \nnastępuje ustawienie odpowiedniego bitu w rejestrze RZ (Rysunek 2).\nRysunek 2. Zgłoszenie przerwania nr 3\nMożliwe jest zgłoszenie kilku przerwań na raz, przykładowo dla przycisków 1, 2 i 4, rejestr zgłoszeń \nbędzie miał postać: %1101. Stan tego rejestru odpowiada zgłoszonym przerwaniom, od momentu \nostatniego resetu układu przerwań.\n3.2 Maskowanie przerwań \nDo rejestru maski można wpisywać różne wartości – jego bity odpowiadają poszczególnym \nprzerwaniom. Jeżeli dany bit jest ustawiony (ma wartość 1), to dane przerwanie uznaje się za \nzamaskowane, a więc jest nieaktywne.\n3.3 Przyjmowanie przerwania \nUkład przerwań dokona przyjęcia przerwania, w momencie uaktywnienia się sygnału eni, oczywiście \nw sytuacji w której jakieś przerwanie zostało zgłoszone. W danej chwili czasu tylko jedno przerwanie \nmoże być obsługiwane na raz – odpowiadający mu bit zostaje wówczas ustawiony w rejestrze przerwań \n(RP). Łatwo można zauważyć, że łączna liczba jedynek w tym rejestrze to maksymalnie 1.\n1 Dokładny opis przyjmowania przerwania znajduje się w następnej części.\nNa przyjęcie danego przerwania ma wpływ kilka czynników:\n1. zgłoszenie danego przerwania, \n2. brak ustawionej maski dla danego przerwania, \n3. brak zgłoszenia przerwania o wyższym priorytecie.\nO ile w przypadku dwóch pierwszych punktów, komentarz jest zbyteczny, to ostatni punkt wymaga \nchwili wyjaśnienia. Poszczególne przerwania mają priorytety – są one zgodne z ich numerami. \nNajwyższy priorytet ma zatem przerwanie nr 1, a najniższy – przerwanie nr 4. Oznacza to, że gdy \nzgłoszonych zostanie kilka przerwań, to do rejestru przerwań trafi zawsze najwyższe, niezamaskowane \nprzerwanie.\nGdy maszyna W przyjmie przerwanie i przejdzie do wykonywania jego procedury obsługi, układ \nprzerwań może zostać zresetowany. Służy do tego sygnał rint. Oznacza to, że można wyzerować rejestr \nprzerwań (RP), ponieważ dane przerwanie zostało już (lub jest aktualnie) obsłużone. Oprócz tego, \nrejestr adresu procedury obsługi przerwania (AP) również może zostać wyzerowany – zostanie to \nopisane w następnej części. Skoro dane przerwanie zostało już obsłużone, może zostać wycofane  i jego \nzgłoszenie – odpowiedni bit rejestru zgłoszeń (RZ) zostaje wyzerowany. Rejestr maski, będący \nrejestrem kontrolującym pracę układu przerwań nie jest modyfikowany przez układ przerwań.\n3.4 Adres procedury obsługi przerwania \nGdy dane przerwanie zostanie przyjęte, w rejestrze AP pojawia się (zostaje wpisany przez układ \nprzerwań) adres procedury obsługi przerwania. Adres ten może zostać następnie pobrany przez \nprocesor, celem przeskoczenie do komórki pamięci wskazywanej przez niego. Adresy poszczególnych \nprzerwań można ustawić w ustawieniach symulatora maszyny W – nie jest to dostępne programowo \n– nie można tego zrobić żadnym rozkazem, ani sygnałem sterującym.\n3.5 Przykład \nW celu lepszego zobrazowania sposobu, w który działa układ przerwań, zostanie wykorzystany \nprzykład przedstawiony poniżej.\nRysunek 3. Zgłoszenie przerwań 1, 2, 3 i 4\nNa rysunku powyżej (Rysunek 3) zostały zgłoszone wszystkie przerwania (1, 2, 3 i 4). W związku z tym, \nw rejestrze zgłoszeń (RZ) pojawiły się same jedynki. Do rejestru maski (RM) zostały wprowadzone dwie \njedynki: maskujące przerwanie nr 1 i 3. Został też uaktywniony sygnał eni – chcemy przyjąć przerwanie.\nRysunek 4. Przyjęcie przerwania nr 2\nRysunek powyżej (Rysunek 4) przestawia stan rejestru układu przerwań w następnym takcie. \nW rejestrze przerwań ustawiony został bit odpowiadający przerwaniu nr 2. Jest to bowiem przerwanie \no najwyższym priorytecie, spośród niezamaskowanych przerwań (2 i 4). W rejestrze AP pojawił się też\nadres procedury obsługi przerwania nr 2, w tym przypadku jest to adres równy 2. Został również \naktywowany sygnał resetujący przerwanie. W normalnej sytuacji sygnał ten pojawia się po pobraniu \nprzez procesor adresu procedury obsługi przerwania.\nRysunek 5. Stan rejestrów po resecie\nRysunek 5 przedstawia stan rejestrów układu przerwań po jego resecie. Rejestry RP i AP zostały \ncałkowicie wyzerowane, a w rejestrze zgłoszeń (RZ) nastąpiło wyzerowanie bitu odpowiadającego \nprzerwaniu, które zostało przyjęte do  obsługi. Sygnał eni został znowu uaktywniony, bowiem chcemy \nprzyjąć kolejne przerwanie.\nRysunek 6. Przyjęcie przerwania nr 4\nRysunek 6 przedstawia przyjęcie kolejnego przerwania. Zgodnie z oczekiwaniami, jest to przerwanie nr \n4, bowiem tylko jego zgłoszenie nie zostało zamaskowane. W rejestrze RP bit nr 4 został ustawiony, \na w rejestrze AP znajduje się odpowiedni adres. Sygnał rint został uaktywniony, celem kolejnego \nzresetowania układu przerwań.\nRysunek 7. Stan rejestrów po ponownym resecie\nNa rysunku powyżej (Rysunek 7) został przedstawiony stan rejestrów po kolejnym resecie. W rejestrze \nRZ bit nr 4 został wyzerowany. Kolejne uaktywnianie sygnału eni w kolejnych taktach nie spowoduje \njuż żadnych zmian w rejestrach – pozostałe przerwania (1 i 3) zostały zamaskowane i są niewidoczne.\n4 Rozkazy przerywalne \nDo tej pory przerwania były omawiane z punktu widzenia układu przerwań. Warto też przyjrzeć się \ndrugiej stronie tego zagadnienie – co tak naprawdę jest przerywane. Na pewno wiadomo, że jest to \nprogram, ale istotne jest zrozumienie, że stwierdzenie wystąpienia przerwania i jego przyjęcie \nnastępuje na poziomie rozkazów, a nie na poziomie instrukcji. Oznacza to, że programista piszący \nprogram w języku asemblera nie sprawdza ręcznie, czy nastąpiło przerwanie – jest ono sprawdzane \npodczas wykonywania rozkazów przerywalnych. Są to rozkazy realizujące zwykłe operacje (jak np. \ndodawanie, odejmowanie itp.), które są odpowiednio zaprojektowane, tzn. dostosowane do \nprzyjmowania przerwań.\nWiększość rozkazów można napisać w wersji przerywalnej. Są jednak takie, które nie powinny dawać \ntakiej możliwości. Przykładowo rozkazy operujące na maskach, a więc służące de facto do kontroli \nukładu przerwań.\nŻeby dany rozkaz był rozkazem przerywalnym, powinien on wykorzystywać sygnały sterujące układem \nprzerwań. Są to zarówno sygnały eni oraz rint, jak i sygnały czytające i piszące do odpowiednich jego \nrejestrów. Poniżej znajduje się kod rozkazu dodawania, napisanego w wersji przerywalnej.",
    "source": "Lab4-przerwania.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. JEŻELI INT TO @przerw GDY NIE @norm; \n5. @norm czyt wys weja dod weak wyl wea KONIEC; \n6. @przerw czyt wys weja dod weak dws; \n7. wyls wes wyws wea; \n8. pisz wyap wel wea rint;\nW powyższym przykładzie wyróżnione zostały elementy związane z obsługą przerwań. Pierwszym \nz nich jest sygnał eni. Pojawia się on w 3 linijce, właściwie na początku rozkazu. Powoduje on, że do \nrejestru przerwań trafia wartość, reprezentujące przyjęte przerwanie, oczywiście w przypadku, \nw którym jakieś przerwanie zostało zgłoszone.\nW linijce 4 znajduje się sprawdzenie, czy jakieś przerwanie zostało przyjęte. Jeżeli tak (czyli jeśli \nw rejestrze RP znajduje się wartość różna od 0), to fraza nastąpi przejście do etykiety @przerw, \nw przeciwnym przypadku – do etykiety @norm.\nGdy żadne przerwanie nie zostało zgłoszone, lub zgłoszone przerwania zostały zamaskowane, \nuaktywniane są standardowe sygnały sterujące towarzyszące kolejnej fazie rozkazu dodawania (linijka \n5).\nW sytuacji, gdy zostało przyjęte jakieś przerwanie (etykieta @przerw), również uaktywniana jest część \nsygnałów rozkazu dodawania, ale bez dwóch ostatnich: wyl wea. Dzieje się tak, ponieważ następną \ninstrukcją wykonaną po rozkazie dodawania, będzie nie ta, o adresie przechowywanym w liczniku, lecz \nta, której adres znajduje się w rejestrze AP.\nWarto zwrócić uwagę, że niezależnie od tego, czy przerwanie zostało przyjęte, czy nie, to operacja \nwykonywana przez ten rozkaz (tutaj jest to dodawanie) zostaje wykonana. Dopiero po jej wykonaniu, \nmoże dojść do ewentualnych czynności związanych z samym przerwaniem.\nW celu zachowania stanu procesora (tj. licznika rozkazów) następuje jego zapisanie na stosie. Odbywa \nsię to w 3 linijkach: 6, 7 i 8, a konkretniej odpowiadają za to następujące sygnały:\n \ndws – dekrementacja wskaźnika stosu, \n \nwyls wes wyws wea – przesłanie zawartości licznika do rejestru S i wprowadzenie do rejestru \nA zawartości wskaźnika stosu, \n \npisz – zapisanie licznika na szczycie stosu.\nGdy stan licznika jest zachowany, następuje pobranie adresu procedury obsługi przerwania (z rejestru \nAP) i wprowadzenie go do licznika i rejestru A: wyap wel wea. Dzięki temu, następnym wykonywanym \nrozkazem będzie pierwszy rozkaz procedury obsługi przerwania.\nNa samym końcu aktywowany jest sygnał rint, który powoduje zresetowanie układu przerwań tak, by \nnastępny przerywalny rozkaz mógł działać poprawnie.\n5 Obsługa przerwań w programach \nAdresy poszczególnych przerwań w maszynie W zostały domyślnie ustawione na wartości \nodpowiadające numerom tychże przerwań, czyli 1, 2, 3 i 4. Oznacza to, że w momencie wystąpienie \ni przyjęcia danego przerwania, rozpocznie się wykonywanie programu od któregoś z tych adresów.\n5.1 Szkielet programu \nJak można łatwo zauważyć, adresy przerwań są kolejnymi wartościami, przez co miejsce na \njakiekolwiek instrukcje ich procedur obsługi właściwie ogranicza się do pojedynczej instrukcji. Ze \nwzględów oczywistych, jeżeli procedura obsługi ma zrobić coś więcej niż tylko przerwać działanie \nprogramu (instrukcja STP), to najsensowniejszym rozwiązaniem jest napisanie jej w innym miejscu, \noznaczonym stosowną etykietą i zastosowaniu instrukcji skoku bezwarunkowego pod danym adresem \nzarezerwowanym na przerwanie. Podobna sytuacja ma miejsce w przypadku programu głównego, \nktóry zaczyna się od adresu 0. Przedstawia to poniższy przykład.\nSOB PROGRAM \n          SOB PRZERW1 \n          SOB PRZERW2 \n          SOB PRZERW3 \n          SOB PRZERW4 \nPROGRAM:  … \n          … \n          … \n          STP \nPRZERW1:  … \n          … \n          … \n          PWR \nPRZERW2:  … \n          … \n          … \n          PWR \nPRZERW3:  … \n          … \n          … \n          PWR \nPRZERW4:  … \n          … \n          … \n          PWR\nPięć pierwszych linijek programu składa się wyłącznie z samych rozkazów skoków bezwarunkowych. \nPonieważ program zaczyna się wykonywać od adresu 0, to następuje skok do etykiety PROGRAM. \nW momencie rozpoczęcia wykonywania procedury obsługi przerwania, następuje przejście do \nodpowiedniego adresu (1 – 4), a następnie skok do etykiety związanej z danym przerwaniem (tutaj \nPRZERWn).\n5.2 Procedura obsługi przerwania \nNa listingu przedstawiającym szkielet programu można zauważyć, że każda procedura kończy się \ninstrukcją PWR. Służy ona do powrotu z tejże procedury, podobnie jak to ma miejsce w przypadku\npodprogramów. Jej zadaniem jest pobranie ze stosu zapisanego tam stanu licznika i przywrócenie go \nw odpowiednie miejsce.\nIstnieje jeszcze jeden rejestr, którego stan winien być zachowany podczas obsługi przerwań. Jest nim \nakumulator – przechowuje on aktualne wyniki działań i mógłby być nadpisany innymi wartościami \npodczas wykonywania procedury obsługi przerwania. W związku z tym, należy zadbać (już w samej \nprocedurze) o jego zachowanie – przykładowo na stosie.\nKolejnym aspektem, na który należy zwrócić uwagę jest możliwość przerwania aktualnie wykonywanej \nprocedury obsługi innego przerwania. Taka sytuacja jest czasami dopuszczalna, ale w przypadku tego \nlaboratorium ograniczymy się do trybu bez wywłaszczania czyli takiego, w którym procedura obsługi \nprzerwania jest nieprzerywalna.\nDo tego celu można wykorzystać rejestr maski. Z rejestrem tym związane są 3 dodatkowe rozkazy:",
    "source": "Lab4-przerwania.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. MAS – zapisuje do rejestru maski wartość będącą jego argumentem (adresowanie\nnatychmiastowe).\nPoniżej znajduje się przykładowy szkielet procedury obsługi przerwania nr 1.\nPRZERW1:  CZM MASKA   // zapis aktualnej maski \n          MAS 15      // zablokowanie wszystkich przerwań \n          DNS         // zachowanie na stosie akumulatora \n          …           // operacje \n          PZS         // pobranie ze stosu akumulatora \n          MSK MASKA   // przywrócenie starej maski \n          PWR         // powrót z procedury obsługi przerwania\nWpisanie wartości 15 do rejestru maski powoduje zamaskowanie wszystkich przerwań (binarnie \n%1111). Bieżąca wartość maski jest zapisywana w zmiennej (pod adresem wskazywanym etykietą \nMASKA). Zawartość akumulatora zapisywana jest na stosie.\n6 Zadania do wykonania",
    "source": "Lab4-przerwania.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Napisać program wypisujący na ekran pojedynczy znak w pętli. Zgłoszenie przerwania powinno\nposkutkować wyświetleniem jego numeru na ekranie.",
    "source": "Lab4-przerwania.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Wykorzystując program z poprzedniego laboratorium (rysowanie kształtów), uzupełnić go\no obsługę przerwań, polegającą na:\na) wyświetlaniu numeru przerwania w momencie jego pojawiania się, \nb) zliczaniu ilości wystąpień każdego z przerwań i wypisaniu ich na koniec pracy\nprogramu, \nc) zakończenia pracy programu na skutek wyświetlenia całej figury lub przekroczenia\nprzez któryś z liczników wartości będącej dwukrotnością numeru danego przerwania \n(2, 4, 6, 8).",
    "source": "Lab4-przerwania.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "Maszyna W\nMaszyna W to uproszczony model rzeczywistego komputera. Schemat najprostszej wersji \nmaszyny W przedstawia rysunek [wstaw odwołanie].\nMaszyna W składa się z kilku podstawowych elementów, takich jak pamięć operacyjna, \njednostka arytmetyczno-logiczna i układ sterujący. Składowe te są połączone poprzez 2 \nmagistrale: magistralę danych i magistralę adresową. Przesyłanie danych miedzy tymi \nelementami jest sterowane za pomocą kilkunastu sygnałów binarnych zwanych sygnałami \nsterującymi. Aby zrozumieć działanie całego układu należy najpierw zapoznać się z działaniem \nkażdego z elementów składowych oraz rolą, jaką pełnią poszczególne sygnały sterujące.\nPamięć operacyjna przechowuje program w postaci ciągu rozkazów komputera oraz dane, na \nktórych ten program jest wykonywany. W dowolnym momencie obliczeń, na życzenie \nprocesora, pamięć udostępnia przechowywane przez siebie dane i rozkazy. Procesor ma także \nmożliwość zapisywania w pamięci wyników wykonywanych przez siebie obliczeń. Pamięć \nskłada się z komórek, każda komórka przechowuje pojedyncze słowo i jest identyfikowana \npoprzez numer komórki nazywany adresem. Aby wykonać jakąś operację na pamięci, procesor \nmusi zawsze podać adres komórki, której ta operacja dotyczy. Aby odczytać określoną komórkę \npamięci, należy najpierw wpisać adres komórki do rejestr adresowego pamięci. Sygnał wea \numożliwia wpisanie do rejestru adresowego pamięci A adresu przesyłanego magistralą \nadresową. W następnym kroku możliwe jest odczytanie odpowiedniej komórki z  pamięci \n(operację aktywuje sygnał czyt) i przesłanie odczytanej wartości na magistralę danych (sygnał \nwys). Aby zapisać coś w pamięci, należy najpierw wpisać adres odpowiedniej komórki pamięci \nw rejestrze adresowym A (sygnał wea) oraz wprowadzić do rejestru słowowego pamięci S \nwartość, jaka ma być zapisana w pamięci. Sygnał wes umożliwia przesłanie zawartości \nmagistrali danych do rejestru S. W następnym kroku należy aktywować sygnał pisz, który \nspowoduje zapisanie zawartości rejestru S w komórce pamięci, której adres znajduje się \nw rejestrze A.\nJednostka arytmetyczno-logiczna (JAL) jest elementem procesora odpowiedzialnym za \nwykonywanie obliczeń. Typowe operacje wykonywane w JAL to dodawanie, odejmowanie, \nsuma i iloczyn logiczny oraz przesunięcia bitowe. Jednostka arytmetyczno-logiczna\n1\nw maszynie W ma tylko jedno wejście. Z tego powodu podczas wykonywania operacji \ndwuargumentowych przyjmuje się, że pierwszy argument znajduje się w związanym z JAL \nrejestrze, zwanym rejestrem akumulatora AK. Zanim zostanie wykonana właściwa operacja \ndwuargumentowa należy wartość pierwszego argumentu wpisać do akumulatora. \nW akumulatorze zapisywane są także wyniki obliczeń wykonywanych w JAL. W najprostszej \nwersji maszyny W, jednostka arytmetyczno-logiczna potrafi wykonywać tylko 3 operacje: \nprzepisywanie stanu wejścia na wyjście (aktywowane sygnałem przep), dodawanie \narytmetyczne (sygnał dod) i odejmowanie (sygnał ode). Sygnał weja powoduje udostępnienie \nwartości na magistrali na wejście JAL, zaś sygnał weak pozwala wynik obliczeń zapisać do \nrejestru akumulatora. Zawartość rejestru akumulatora można wyprowadzić na magistralę \ndanych, zadanie to realizuje sygnał wyak. Obliczenia w JAL wykonywane są na liczbach \nbinarnych zapisanych w zapisie uzupełnieniowym do 2. W dowolnym momencie obliczeń \nmożliwe jest sprawdzenie, czy w akumulatorze znajduje się liczba ujemna, czy też nieujemna. \nW tym celu wystarczy sprawdzić bit znaku liczby przechowywanej w akumulatorze (nazywany \nsygnałem stanu Z). Jeśli liczba w akumulatorze jest liczbą ujemną, bit Z będzie miał wartość 1. \nW przeciwnym przypadku bit ten będzie równy 0. Układ sterujący procesora może sterować \nwykonywaniem obliczeń w różny sposób w zależności od stanu bitu Z.\nUkład sterujący na podstawie stanu maszyny W (czyli zawartości poszczególnych rejestrów, \ntworzących ten układ) określa sygnały sterujące, jakie w danym momencie mają być aktywne. \nRejestrami wpływającymi na działanie układu sterującego oprócz akumulatora są rejestr \ninstrukcji I oraz rejestr licznika rozkazów L. Licznik rozkazów przechowuje adres kolejnego \nrozkazu do wykonania. Ponieważ najczęściej kolejne następujące po sobie rozkazy znajdują się \nw kolejnych komórkach pamięci,, do licznika rozkazów dodano sygnał il, którego zadaniem \njest inkrementacja tego rejestru. Ponadto z licznikiem rozkazów związane są 2 inne sygnały. \nSygnał wel aktywuje operację zapisania w rejestrze L aktualnej zawartości magistrali \nadresowej, zaś sygnał wyl powoduje wyprowadzenie zawartości rejestru na magistralę. W \nrejestrze instrukcji przez większość czasu wykonywania rozkazu znajduje się słowo opisujące \nwykonywany rozkaz. Rejestr ten można podzielić na 2 części. Starsza część rejestru \nprzechowuje kod rozkazu, zaś młodsza AD argument. Najczęściej argumentem jest adres \nkomórki, do której odwołuje się dany rozkaz. Sygnał wyad pozwala wyprowadzić argument na \nmagistralę danych.. Drugim sygnałem związanym z rejestrem instrukcji jest sygnał wei. \nPowoduje on przepisanie słowa opisującego rozkaz do wykonania z magistrali danych do \nrejestru I. Należy podkreślić, że w poprawnie zaprojektowanym rozkazie sygnał wei występuje \nzawsze tylko i wyłącznie w pierwszej fazie rozkazu.\n2\nProjektowanie rozkazów\nJednym z etapów projektowania procesora jest ustalenie listy rozkazów realizowanych przez \ndany procesor oraz zdefiniowanie, dla każdego rozkazu, sekwencji działań potrzebnych do jego \nwykonania. Pod pojęciem projektowania rozkazu będziemy rozumieć ustalenie przebiegów \nsygnałów sterujących, powodujących wykonanie wszystkich przesyłów międzyrejestrowych, \nskładających się na dany rozkaz.\nKażdy rozkaz wykonywany jest etapami. Pierwszy etap to pobranie i zdekodowanie rozkazu. \nDopiero po zakończeniu tego etapu procesor jest w stanie określić jaki rozkaz wykonuje. \nOznacza to, że etap pobrania i dekodowania musi być wykonywany identycznie dla wszystkich \nprojektowanych rozkazów. W maszynie W wykonanie tego etapu realizowane jest jako \npierwsza faza rozkazu i składają się na nią sygnały: czyt (odczytanie komórki pamięci), wys \n(przesłanie zawartości odczytanej komórki na magistralę danych), wei (wprowadzenie \nodczytanej zawartości do rejestru instrukcji) i il (inkrementacja licznika rozkazów). \nW kolejnych fazach będą realizowane dalsze etapy wykonania rozkazu. Są to: ustalenie adresu \nefektywnego argumentu, jego odczyt i wykonanie na nim właściwej operacji oraz \nprzygotowanie do wykonania następnego rozkazu. Cały proces projektowania rozkazów \nzostanie przedstawiony na przykładzie rozkazu dodawania.\nPrzykład 1\nZaprojektować rozkaz dodawania DOD Ad. W wyniku działania tego rozkazu do akumulatora \nnależy dodać zawartość komórki pamięci, której adres jest argumentem projektowanego \nrozkazu.\nDziałanie rozkazu można opisać za pomocą przesyłu międzyrejestrowego (Ak)+((Ad))→Ak. \nPodobnie jak w przypadku każdego innego rozkazu, zaczniemy od fazy pobrania i dekodowania \nrozkazu. Najpierw należy odczytać rozkaz z pamięci i przesłać go do rejestru instrukcji oraz \nzwiększyć o 1 zawartość licznika rozkazów. Wykonanie tych działań wymaga uaktywnienia \nsygnałów czyt, wys, wei i il. Te właśnie sygnały będą tworzyć pierwszą fazę wykonania rozkazu \ndodawania.\nPo zdekodowaniu konkretnego rozkazu można już przystąpić do charakterystycznych dla niego \ndziałań. W tym przypadku do akumulatora musimy dodać zawartość komórki pamięci, której \nadres jest argumentem rozkazu. Samo dodawanie będzie poprzedzone odczytaniem zawartości \nodpowiedniej komórki pamięci. Zawsze odczytywana jest komórka, której adres znajduje się \nw rejestrze adresowym układu pamięci (rejestrze A). Tymczasem adres komórki, którą mamy \nodczytać znajduje się w części adresowej (Ad) rejestru instrukcji. Przed odczytaniem z pamięci \nnależy zatem przesłać zawartość rejestru Ad do rejestru A. Przesył taki będzie wykonany po \nuaktywnieniu sygnałów wyad (wyprowadzenie zawartości części adresowej rejestru instrukcji \nna magistralę adresową) i wea (zapisanie zawartości magistrali adresowej w rejestrze A układu \npamięci). Te dwa sygnały (wyad i wea) tworzą drugą fazę realizacji rozkazu dodawania.\nWszystkie pozostałe czynności zostaną wykonane w trzeciej fazie wykonania tego rozkazu. \nA będą to: odczytanie argumentu z pamięci (aktywowane sygnałem czyt), przesłanie go do \njednostki arytmetyczno-logicznej (co wymaga sygnałów wys i weja), wykonanie dodawania \n(dod) i zapisanie jego wyniku w akumulatorze (weak). Dodatkowo, ponieważ trzecia faza \nbędzie ostatnią fazą realizacji rozkazu dodawania, musimy pamiętać o przesłaniu adresu\n3\nnastępnego rozkazu do wykonania z rejestru licznika rozkazów (L) do rejestru adresowego \npamięci (A). Ten przesył zostanie zrealizowany dzięki sygnałom wyl i wea.\nTym samym końcową postać rozkazu dodawania tworzą trzy fazy. W pierwszej aktywne muszą \nbyć sygnały: czyt, wys, wei i il; w drugiej: wyad i wea; wreszcie w trzeciej: czyt, wys, weja, dod, \nweak, wyl i wea. Działanie zaprojektowanego rozkazu można przetestować dzięki \nprogramowemu symulatorowi maszyny W. Po jego uruchomieniu, należy zwykle utworzyć \nnowy plik z opisem rozkazu, skompilować go (co spowoduje dodanie rozkazu do listy \nrozkazów maszyny W) a następnie sprawdzić jego działanie1. Opis rozkazu dodawania \nzamieszczono poniżej:\nROZKAZ DOD; \nczyt wys wei il; \nwyad wea; \nczyt wys weja dod weak wyl wea;\nPierwsza linia zawiera nazwę rozkazu, w kolejnych liniach wymieniono sygnały sterujące \naktywne w poszczególnych taktach rozkazu. Średnik na końcu każdej linii (od 2 do 4) oznacza \nkoniec taktu. Rozkaz DOD za każdym razem będzie wykonywany tak samo. Jednakże istnieją \nrozkazy, które realizowane są różnie w zależności od aktualnego stanu procesora.\nPrzykład 2\nZaprojektować rozkaz skoku warunkowego SOZ Ad, który spowoduje ustalenie adresu \nnastępnego rozkazu w zależności od zawartości akumulatora. Jeśli w akumulatorze jest liczba \nróżna od 0, następnym wykonywanym rozkazem ma być rozkaz znajdujący się w kolejnej \nkomórce pamięci. Jeżeli zawartość akumulatora jest równa 0, następnym rozkazem będzie ten, \nktóry zapisano w komórce pamięci o adresie podanym jako argument rozkazu.\nGłównym celem rozkazu SOZ jest ustalenie adresu następnego wykonywanego rozkazu. Jeśli \nw akumulatorze będzie 0, jako następny zostanie wykonany rozkaz, którego adres podano jako \nargument rozkazu SOZ. W przeciwnym razie przejdziemy do wykonywania rozkazu \nznajdującego się w pamięci bezpośrednio za rozkazem SOZ.\nJak zwykle pierwszą fazę projektowanego rozkazu tworzą sygnały czyt, wys, wei i il. Następnie \nnależy sprawdzić, czy w akumulatorze znajduje się 0. Jest to możliwe dzięki istnieniu \nodpowiednich sygnałów stanu procesora. W maszynie W mamy do dyspozycji 2 takie sygnały: \nZ (znak liczby) – informujący czy w akumulatorze jest liczba ujemna oraz ZAK, który \nprzyjmuje wartość 1, gdy w akumulatorze jest 0. Aby zaprojektować rozkaz SOZ należy \nskorzystać z sygnału ZAK. Jeżeli ZAK = 1, to w akumulatorze jest 0 a to oznacza, że należy \nwykonać skok, czyli przesłać do rejestrów L i A adres znajdujący się w części adresowej \nrejestru instrukcji. Wymaga to uaktywnienia sygnałów wyad, wel i wea. Jeżeli ZAK = 0, to w \nakumulatorze jest liczba różna od 0 a w takim przypadku adres następnego rozkazu znajduje \nsię w rejestrze L (po wykonaniu inkrementacji w pierwszej fazie) i wystarczy go przesłać do \nrejestru adresowego pamięci. Z tym przesyłem związane są sygnały wyl i wea. Pełny projekt \nrozkazu SOZ zamieszczono poniżej.\nROZKAZ SOZ; \nczyt wys wei il; \nJEZELI ZAK TO @zero GDY NIE @niezero;\n4\n@zero wyad wea wel KONIEC; \n@niezero wyl wea;\nWarto zwrócić uwagę na trzecią linię kodu. Zawiera ona sprawdzenie stanu testowanego \nsygnału ZAK. Jeżeli ZAK = 1 (jest 0 w Ak) następuje przejście do wykonywania sygnałów \nzapisanych w linii oznaczonej etykietą @zero. Gdy ZAK = 0, jako następne zostaną wykonane \nsygnały sterujące wpisane w linii której etykieta (@niezero) pojawia się po frazie GDY NIE. \nZauważmy też, że w sytuacji, gdy podawana jest lista sygnałów aktywnych w ostatnim takcie \nrozkazu a nie jest to ostatnia linia opisu rozkazu, konieczne jest dopisanie słowa kluczowego \nKONIEC (tak jak jest to w czwartej linii opisu rozkazu SOZ).\nPrzykład 3\nZaprojektować rozkaz dekrementacji akumulatora DEC. W wyniku działania tego rozkazu od \nakumulatora należy odjąć jedynkę. Wykorzystać architekturę W+.\nZadanie to to przykład bardziej złożonego rozkazu, wymagającego rozbudowy maszyny W \no dodatkowe połączenie, umożliwiające przesył danych bezpośrednio między magistralami \nsłowową i adresową. Jego rozwiązanie zostanie przedstawione za pomocą listy elementarnych \nprzesyłów międzyrejestrowych. Następnie do każdego przesyłu zostaną przyporządkowane \nodpowiednie sygnały sterujące i wreszcie na koniec sygnały te zostaną odpowiednio \nrozmieszczone w czasie (tzw. podział na takty). Jest to typowa kolejność działań przy \nprojektowaniu rozkazów.\nNiestety nasza jednostka arytmetyczno-logiczna jest bardzo uboga i nie oferuje bezpośrednio \noperacji inkrementacji i dekrementacji akumulatora. Stąd konieczne jest bardziej \nskomplikowane postępowanie. Najpierw do akumulatora zostanie dodana aktualna zawartość \nlicznika rozkazów, następnie licznik zostanie zinkrementowany (zostanie dodana jedynka do \nzawartości licznika). Z kolei zwiększona zawartość licznika zostanie odjęta od akumulatora, co \nw efekcie spowoduje, że w akumulatorze znajdzie się wartość o 1 mniejsza od jego pierwotnej \nzawartości. Oczywiście nie wolno zapomnieć o przywróceniu oryginalnej zawartości licznika \nrozkazów. Będzie to możliwe dzięki wcześniejszemu jej zapamiętaniu w rejestrze S. Całość \ndziałań składających się na wykonanie rozkazu dekrementacji przedstawiają poniższe przesyły \nmiędzyrejestrowe.\n((A)) → I \n(L) + 1 → L \n(L) → S \n(Ak) + (L) → Ak \n(L) + 1 → L \n(Ak) – (L) → Ak \n(S) → L \n(S) → A\nZ każdym z powyższych przesyłów wiążą się określone sygnały sterujące. Dopiszmy je \nzatem obok związanych z nimi przesyłów. Dodatkowo poszczególne linie zostaną \nponumerowane.\n1. ((A)) → I czyt wys wei\n5\n2. (L) + 1 → L il\n3. (L) → S wyl as wes\n4. (Ak) + (L) → Ak wyl as weja dod weak\n5. (L) + 1 → L il\n6. (Ak) – (L) → Ak wyl as weja ode weak\n7. (S) → L wys sa wel\n8. (S) → A wys sa wea\nSygnały as i sa są związane w wprowadzonym połączeniem między magistralami. Sygnał \nas powoduje przesłanie na magistralę danych zawartości magistrali adresowej, zaś sygnał sa \nprzepisze zawartość magistrali danych na magistralę adresową („zgubione” zostaną najstarsze \nbity stanu magistrali danych).\nAby uzyskać pełny projekt rozkazu musimy jeszcze rozmieścić poszczególne operacje \nw czasie. Dążymy przy tym do wykonania możliwie wielu operacji w pojedynczym takcie.\nTradycyjnie przesyły przedstawione w dwóch pierwszych liniach realizowane są w \npierwszej fazie każdego rozkazu. W kolejnej fazie zostaną wykonane przesyły z linii 3, 4 i 5. \nTrzecią fazę będzie stanowić przesył umieszczony w linii 6. Zaś dwa ostatnie można połączyć \njako ostatnią fazę wykonania rozkazu. Tym samym ostateczny projekt rozkazu będzie mieć \npostać jak poniżej\nROZKAZ DEC; \nARGUMENTY 0; \nczyt wys wei il; \nwyl as wes weja dod weak il; \nwyl as weja ode weak; \nwys sa wel wea;\nWyjaśnienia wymaga polecenie umieszczone w drugiej linii opisu rozkazu. Projektowany przez \nnas rozkaz nie wykorzystuje pola przeznaczonego na argument (dekrementowana jest \nzawartość akumulatora a nie np. jakiejś komórki w pamięci, której adres mógłby być \nargumentem rozkazu). Ten fakt został zaznaczony odpowiednim wpisem.\nZadania do wykonania\nPrzesyły międzyrejestrowe \nPosługując się mechanizmem sterowania ręcznego zrealizować następujące przesyły \nmiędzyrejestrowe (nie rozkazy !). Przyjąć, że zawartości poszczególnych rejestrów nie są \nokreślone (odpowiednie wartości liczbowe należy „wypracować”)\n1. ((AD)) → Ak \n2. (Ak) shl 1 → 0 // przesunięcie logiczne o 1 bit w lewo (maszyna W+) \n3. |((L))| → Ak \n4. |(Ak)| → (2) \n5. (Ak) – ((L)) → Ak \n6. (Ad) – (Ak) → 1 \n7. 2 * (Ak) → Ak\n6\n8. (0) + (1) → (Ad) \n9. (Ak) → (L) \n10. ((Ad)+1) – ((Ad)) → Ak \n11. – (AK) → (Ad) \n12. (Ak)+((L)) → (L)+1 \n13. (Ak) + (S) → (Ad) \n14. ((Ad)) + (Ak) → (L)+1 \n15. |(Ak)| → (L) \n16. ((Ad)) + ((Ad)+1) → Ak",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Zaprojektować rozkaz MIN Ad porównujący zawartość akumulatora z zawartością\nkomórki pamięci, której adres jest argumentem rozkazu i zapisujący w akumulatorze \nmniejszą z nich.",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Zaprojektować rozkaz MAX Ad porównujący zawartość akumulatora z zawartością\nkomórki pamięci, której adres jest argumentem rozkazu i zapisujący w akumulatorze \nwiększą z nich.",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. Zaprojektować rozkaz MN2 Ad zapisujący w akumulatorze 2-krotność zawartości\nkomórki pamięci, której adres jest argumentem rozkazu.",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. Zaprojektować rozkaz ABS Ad wpisujący do akumulatora wartość bezwzględną\nliczby znajdującej się w komórce pamięci, której adres jest argumentem rozkazu",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "5. Zaprojektować rozkaz skoku warunkowego SNZ Ad, który spowoduje ustalenie\nadresu następnego rozkazu w zależności od zawartości akumulatora. Jeśli w \nakumulatorze jest 0, następnym wykonywanym rozkazem ma być rozkaz znajdujący \nsię w kolejnej komórce pamięci. Jeżeli zawartość akumulatora jest różna od 0, \nnastępnym rozkazem będzie ten który zapisano w komórce pamięci o adresie \npodanym jako argument rozkazu.",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. Zaprojektować bezargumentowy rozkaz dekrementacji akumulatora. W wyniku\ndziałania tego rozkazu zawartość akumulatora powinna zostać zmniejszona o 1.",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "7. Zaprojektować rozkaz dodawania z adresacją pośrednią DDP Ad. W wyniku działania\ntego rozkazu do akumulatora należy dodać zawartość komórki pamięci, której adres \nznajduje się w komórce pamięci, której adres jest argumentem rozkazu. Wykorzystać \narchitekturę W+.",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "8. Zaprojektować rozkaz odejmowania z adresacją pośrednią ODP Ad. W wyniku\ndziałania tego rozkazu od akumulatora należy odjąć zawartość komórki pamięci, \nktórej adres znajduje się w komórce pamięci, której adres jest argumentem rozkazu. \nWykorzystać architekturę W+.",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "9. Zaprojektować rozkaz pobierania z adresacją pośrednią PBP Ad. W wyniku działania\ntego rozkazu do akumulatora należy przesłać zawartość komórki pamięci, której adres \nznajduje się w komórce pamięci, której adres jest argumentem rozkazu. Wykorzystać \narchitekturę W+.",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "10. Zaprojektować rozkaz ładowania do pamięci z adresacją pośrednią ŁDP Ad. W\nwyniku działania tego rozkazu zawartość akumulatora należy zapisać w komórce \npamięci, której adres znajduje się w komórce pamięci, której adres jest argumentem \nrozkazu. Wykorzystać architekturę W+.",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "11. Zaprojektować rozkaz zamiany zawartości 2 komórek pamięci: komórki, której adres\njest umieszczony w części adresowej rozkazu i komórki znajdującej się bezpośrednio\n7\nza rozkazem. Przyjąć, że następny rozkaz znajduje się o 2 komórki za projektowanym \nrozkazem.\n8",
    "source": "Projektowanie rozkazów.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. Searching an array for the greatest element and storing its value and index in separate variables (allocated\nand labeled memory cells).",
    "source": "lab4v8 Programming in assembly language of machine W new.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "7. Searching an array for the lowest element and storing its value and index in separate variables (allocated\nand labeled memory cells).",
    "source": "lab4v8 Programming in assembly language of machine W new.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "8. Searching for a value specified in a separate variable and storing the index of its first occurrence. [a, b, c]",
    "source": "lab4v8 Programming in assembly language of machine W new.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "9. Searching for a value specified in a separate variable and counting a number of occurrences. \n  [a, b, c] \n(grade 5):",
    "source": "lab4v8 Programming in assembly language of machine W new.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "12. Swapping pairs of an array’s elements. The length of the array is a given even value.  \n[a] \nEx.: ABCDEF -> BADCFE",
    "source": "lab4v8 Programming in assembly language of machine W new.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "18. Evaluating a determinant of 3 x 3 matrix. The matrix is stored as a one-dimensional table.\n\n\n\n\nk\nn",
    "source": "lab4v8 Programming in assembly language of machine W new.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "19. Evaluating a value of symbol \n\n\n.\n- \n[a] \na number of elements specified in a separate variable,",
    "source": "lab4v8 Programming in assembly language of machine W new.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "- \n[c] \nuse of a special characteristic value to indicate the end of an array (especially useful in case of \nthe “find a pattern” type of task).",
    "source": "lab4v8 Programming in assembly language of machine W new.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "RST 0  \n; end of an array (string)\nTheory of Computer Science   Lab2 \nProgramming in assembly language of machine W 2018   p.2\nAdditional information:",
    "source": "lab4v8 Programming in assembly language of machine W new.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "List of instructions with mnemonic and code\nexample – Evaluating a sum of values of all elements of an array:",
    "source": "lab4v8 Programming in assembly language of machine W new.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "//Calculate the product of two natural numbers\nLOOP:\nPOB     PRODUCT\nDOD     A\nLAD     PRODUCT\nPOB     B\nODE     ONE\nSOZ     END\nLAD     B\nSOB     LOOP\nEND:\nPOB     PRODUCT\nSTP\nONE:    RST 1\nA:      RST 6\nB:      RST 3\nPRODUCT:   RST 0\n//Search an array for a value specified in a separate variable and store the index of its first\noccurrence.\n//use an additional variable to indicate the end of an array\n//CharValue: RST 0  // additional variable\n//ARRAY: RST 1\n//RST 2\n//RST 3\n//RST 0  // end of an array\nNEXT: POB ARRAY\nSOM END_OF_ARRAY\nODE SEARCHED\nSOZ FOUND\nL1:\nPOB INDEX\nDOD ONE\nLAD INDEX\nPOB NEXT\nDOD ONE\nLAD NEXT\nSOB NEXT\nFOUND:  STP\nEND_OF_ARRAY: STP\nSEARCHED: RST 7\nINDEX: RST 1\nONE: RST 1\nCharValue: RST -1  // additional variable\nARRAY: RST 1\nRST 2\nRST 2\nRST 7\nRST -1  // end of an array\n//Decrement all elements of an array.\nloop:\nPOB size\nODE one\nSOM end\nLAD SIZE\ninst1: POB ARRAY\nODE DecrementBy\ninst2: LAD ARRAY\nPOB inst1\nDOD one\nLAD inst1\nPOB inst2\nDOD one\nLAD inst2\nSOB loop\nend:\nSTP\nSIZE: RST 8  //number of elements: 3\nARRAY: RST 8\nRST 10\nRST 3\nRST 1\nRST 2\nRST 3\nRST 4\nRST 5\nDecrementBy: RST 2\none: RST 1\n//Search an array for a value specified in a separate variable and count the number of occurrences.\nloop:\ninst: POB array\nODE CharValue\nSOZ end\nDOD CharValue\n//checking the value in the array\nODE LookedForValue\nSOZ OccurenceFound\nSOB continue\nOccurenceFound: POB occurences\nDOD one\nLAD occurences\ncontinue: POB inst\nDOD one\nLAD inst\nSOB loop\nend: POB occurences\nSTP\nCharValue: RST 0\nARRAY: RST -3\nRST 2\nRST 3\nRST 5\nRST 6\nRST 5\nRST 10\nRST -3\nRST 0\nLookedForValue: RST -3\noccurences: RST 0\none: RST 1\n//Decrement all elements of an array.\n//the number of elements of the array is specified in a separate variable\n//SIZE: RST 3  //number of elements: 3\n//ARRAY: RST 1\n//RST 2\n//RST 3\nTABLE_SIZE: POB     SIZE\nODE     ONE\nSOM     END\nLAD     SIZE\nSUB: POB     ARRAY\nODE     ONE\nWHERE: LAD     ARRAY\nL1: POB     SUB\nDOD     ONE\nLAD     SUB\nPOB     WHERE\nDOD     ONE\nLAD     WHERE\nSOB     TABLE_SIZE\nEND: STP\nONE:    RST 1\nSIZE:   RST 2\nARRAY:  RST 1\nRST 2\nRST 3\nRST 4\nRST 5\nRST 6\n//product of 2 natural numbers\n//SDP Product\n//STP\nMain:\n//determining the counter value\nPOB N2\nSOZ end\nSOM Negative\nLAD Counter\n//determining the Product value\nPOB N1\nSOZ end\nLAD Product\nLAD First_Prdct\nloop:\nPOB Counter\nODE One\nLAD Counter\nSOZ end\nPOB Product\nDOD First_Prdct\nLAD Product\nSOB loop\n//if counter is negative, change values of counter and Product\nNegative:\nLAD Product\nLAD First_Prdct\nPOB N1\nSOZ end\nLAD Counter\nSOB loop\nend:\nPOB Product\nSTP\nOne: RST 1\nN1: RST 4\nN2: RST 10\nFirst_Prdct: RPA\nCounter: RPA\nProduct: RPA\n//adding all elements in the array\nloop:\nPOB size\nODE one\nSOM end\nLAD size\nPOB sum\ninst: DOD array\nLAD sum\n//incrementing index of the array\nPOB inst\nDOD one\nLAD inst\nSOB loop\nend:  POB sum\nSTP\narray: RST 1\nRST 3\nRST 4\nRST 3\nsize: RST 4\none: RST 1\nsum: RST 0\n//Evaluate exponentiation of two natural numbers\nPOB Final\nDOD Num1\nLAD Final\nPOB Num2\nSOZ end_exp_one\nPOB Num1\nSOZ end_exp_zero\nMain_exp:\nPOB Num2\nODE one\nSOZ end_exp\nLAD Num2\n//Program below multiplies 2 numbers\nMain_product:\nPOB Num1\nLAD N1\nPOB Final\nLAD N2\n//determining the counter value\nPOB N2\nSOZ end\nSOM Negative\nLAD Counter\n//determining the Product value\nPOB N1\nSOZ end\nLAD Product\nLAD First_Prdct\nloop:\nPOB Counter\nODE One\nLAD Counter\nSOZ end\nPOB Product\nDOD First_Prdct\nLAD Product\nSOB loop\n//if counter is negative, change values of counter and Product\nNegative:\nLAD Product\nLAD First_Prdct\nPOB N1\nSOZ end\nLAD Counter\nSOB loop\nend:\nPOB Product\nLAD Final\nSOB Main_exp\n//End of multiplication\nend_exp:\nPOB Final\nSTP\nend_exp_one:\nPOB one\nSTP\nend_exp_zero:\nPOB zero\nSTP\nOne: RST 1\nN1: RST 0\nN2: RST 0\nFirst_Prdct: RPA\nCounter: RPA\nProduct: RPA\n//For multiplication\nNum1: RST 5\nNum2: RST 0\nFinal: RST 0\nzero: RST 0",
    "source": "programs_tocs.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "MINUT 2020 (1), s. 124–135\nISSN 2719-3063\nRobert BRZESKI1\n1Wydział Automatyki, Elektroniki i Informatyki, Politechnika Śląska, ul. Akademicka 16, 44-100 Gliwice\nPrawidłowe tworzenie rozkazów asemblerowych dla Maszyny W\ncz.1\nStreszczenie. W artykule przedstawiono przykłady implementacji kilku rozkazów asemblero-\nwych dla Maszyny W wraz z omówieniem błędów realizowanych przez studentów. Pokazano typowe\nproblemy występujące przy implementacji rozkazów oraz zaprezentowano i omówiono prawidłowe\nrozwiązania. W zakresie prezentacji błędów popełnianych przez studentów skupiono się na tych\nnajczęściej występujących. Przedstawiono także w punktach, zakres materiału teoretycznego po-\ntrzebnego do opanowania, jeszcze przed przystąpieniem do realizacji zadań praktycznych. Zestaw\nten może być przydatny jako lista kontrolna wstępnie wymaganej wiedzy.\nSłowa kluczowe: rozkaz, asembler, optymalizacja, Maszyna W.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. Wprowadzenie do implementacji rozkazów dla Maszyny W\nW procesie dydaktycznym realizowanym na wydziale Automatyki Elektroniki i Informatyki Poli-\ntechniki Śląskiej, na kilku kierunkach, w ramach przedmiotu Postawy Informatyki, realizowane jest za-\ngadnienie projektowania rozkazów dla Maszyny W. Pojęcie Maszyny W odnosi się do idei konstrukcji\ni działania uproszczonego komputera. Zawiera on w sobie podstawowe, najważniejsze elementy maszyny\ncyfrowej, zgodnej z obecnie powszechnie używaną architekturą von Neumanna. Na prowadzonych zaję-\nciach, w szczególności podczas laboratorium, studenci używają Maszyny W, w postaci programowego\nsymulatora [Rysunek 1]. Zadaniem studentów jest zaimplementowanie przy użyciu mikrosygnałów, po-\njedynczego rozkazu asemblerowego. Taki rozkaz wykonywany jest w kilku osobnych cyklach procesora\nzwanych taktami. W każdym takcie należy umieścić odpowiedni zestaw sygnałów mikrosterujących i za-\nkończyć go znakiem reprezentującym koniec taktu. Dla obecnie używanego na laboratorium symulatora\njest to średnik. Implementacja rozkazu na dostępnym symulatorze realizowana jest w następującej postaci:\n// Dwa znaki ukośnika oznaczają komentarz. Jest on opcjonalny ale warto tu wpisać treść rozkazu która\nbędzie implementowana.\nROZKAZ nazwaRozkazu;\nNastępnie trzeba umieścić predefiniowane słowo ‘ROZKAZ’ oraz własną nazwę implementowanego\nrozkazu. Całość trzeba zakończyć średnikiem.\nAutor korespondencyjny: R. Brzeski (Robert.Brzeski@polsl.pl).\nData wpłynięcia: 01.10.2020.\nPrawidłowe tworzenie rozkazów asemblerowych dla Maszyny W cz.1\n125\nArgumenty liczbaArgumentów;\nKolejną, tym razem opcjonalną częścią jest wpisanie liczby argumentów obsługiwanych przez im-\nplementowany rozkaz. Wartością domyślną jest jeden.\nczyt wys wei il;\nPierwszy takt rozkazu. Jest on zawsze taki sam – nie można tu nic dodać ani niczego pominąć. Dla\nkażdego rozkazu składa się z zestawu tych samych czterech mikrosygnałów.\nKolejne takty – zestawy mikrosygnałów;\nKażdy takt trzeba zakończyć średnikiem.\nTak zaimplementowany rozkaz, można skompilować na dostępnym symulatorze i uruchomić/wykonać.\nWykorzystanie skompilowanego rozkazu najczęściej odbywa się poprzez użycie go i wykonanie w progra-\nmie, napisanym w języku asemblera Maszyny W, czyli zestawie tego typu rozkazów.\nPrzed implementacją rozkazu można utworzyć jego projekt w postaci algorytmu, zapisanego w do-\nwolny sposób (np. słownie lub przy użyciu schematu blokowego lub za pomocą poszczególnych przesyłów\npomiędzy rejestrami lub pamięcią).\nCelem tego artykułu nie jest przedstawianie podstawowych informacji na temat struktury i działania\nMaszyny W. Taką podstawową wiedzę można uzyskać nie tylko na wykładach, ćwiczeniach czy poprzez\nzaznajomienie się z materiałami do laboratorium z tego tematu, ale także w opublikowanych artykułach\ni skryptach [1–5]. W bieżącym artykule zakłada się, że czytelnik ma już podstawową wiedzę teoretyczną\ni chciałby poszerzyć ją o praktyczne wskazówki dotyczące implementacji rozkazów.\nRysunek 1. Widok okna symulatora Maszyny W, w wersji W+\n126\nR. Brzeski\nW ramach tego artykułu przyjmuje się, że czytelnik ma taką wiedzę jaką powinien mieć student\nprzystępujący do laboratorium z opisywanej tematyki, czyli:",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. Wie gdzie znajduje się magistrala danych, adresowa oraz połączenie między magistralami, wraz\nz mikrosygnałem sa.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "8. Zna strukturę rozkazu oraz ideę działania podstawowych, predefiniowanych rozkazów dla Maszyny\nW (np. rozkazu DOD, SOM, SOB).",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "10. Rozumie ideę podziału/grupowania mikrosygnałów na takty oraz to dlaczego nie jest możliwe wy-\nkonanie całego rozkazu w jednym takcie.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "12. Rozumie sposób zapisu treści rozkazu, w tym między innymi interpretację liczby nawiasów w których\numieszczone są nazwy rejestrów.\nPowyższe założenia mogą stanowić dla studenta, swego rodzaju listę kontrolną, z zakresu wiadomości\npotrzebnych do opanowania, jeszcze przed przystąpieniem do ćwiczeń laboratoryjnych. W ramach labo-\nratorium student będzie miał możliwość wdrożenia wiedzy teoretycznej w czasie implementacji zadanych\nrozkazów asemblerowych. Treść zadań do wykonania będzie przedstawiona w postaci opisu słownego lub\nw formie skróconej przy użyciu: nazw rejestrów (reprezentowanych przez skróty literowe), nawiasów, wy-\nkonywanych operacji lub warunków i wykonywanego przesyłu (przesyłu wartości pomiędzy rejestrami lub\npamięcią). Przesył reprezentowany przez znak ‘→’ oznacza, że wartość uzyskana po lewej stronie →jest\nprzesyłana w miejsce wskazywane po prawej stronie →. Skróty literowe oznaczają poszczególne rejestry.\nW najprostszej sytuacji np.: (A) →B oznacza, że wartość rejestru A należy przesłać do rejestru B. Na-\nwiasy występują wokół skrótów literowych rejestru. Liczba nawiasów ma kluczowe znaczenie. Inaczej jest\nrozumiana po lewej, a inaczej po prawej stronie przesyłu. Wyjaśnienie liczby nawiasów przedstawione jest\nna przykładowym rejestrze o nazwie R:\nW zależności od liczby nawiasów po lewej stronie przesyłu:\n(R) – oznacza wartość znajdującą się w rejestrze R.\n((R)) – oznacza wartość znajdującą się w pamięci o adresie wskazywanym przez rejestr R.\nPrawidłowe tworzenie rozkazów asemblerowych dla Maszyny W cz.1\n127\n(((R))) – oznacza, że wartość rejestru R jest adresem (wskaźnikiem) do komórki pamięci, którego\nwartość ponownie jest wskaźnikiem do pamięci, spod którego należy odczytać (pobrać) wartość.\nNatomiast po prawej stronie przesyłu:\n(R) - oznacza, że uzyskaną wcześniej wartość, należy zapisać do pamięci o adresie wskazywanym przez\nrejestr R (adresie umieszczonym w rejestrze R).\n((R)) - oznacza, że wartość rejestru R jest adresem (wskaźnikiem) do komórki pamięci, którego wartość\nponownie jest wskaźnikiem do pamięci, pod który należy zapisać wartość ‘operacji’ uzyskaną z lewej\nstrony przesyłu ‘→’.\nArtykuł ten jest efektem kilkunastoletnich doświadczeń autora w prowadzeniu zajęć z Podstaw Infor-\nmatyki, a przedstawione w rozdziale 2 i 3 nieprawidłowości w trakcie tworzenia rozkazów, są oparte na\nfaktycznie popełnianych przez studentów błędach.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Ogólne wytyczne dotyczące prawidłowej implementacji rozkazów\nW trakcie realizacji przez studentów otrzymanych zadań, dość często pojawia się kilka ogólnych za-\ngadnień utrudniających implementację rozkazu.\nJednym z problemów jakie napotykają studenci jest przeświadczenie o braku wystarczającej liczby do-\nstępnych rejestrów. Wynika to np. z próby zachowania wartości pierwotnych - występujących w rejestrach\nw momencie rozpoczęcia wykonywania pierwszego taktu rozkazu. Zanim podejmie się próbę zachowania\nwartości pierwotnej, należy przeanalizować treść zadania do wykonania (czynności wykonywane w trak-\ncie realizacji rozkazu) i wywnioskować czy taka potrzeba w ogóle istnieje. Być może dana wartość i tak\nbędzie zmieniona i nie ma potrzeby, aby ją przechowywać. Jeżeli nie wynika to jawnie z treści zadania,\nto wartości pierwotnych rejestru AK, A oraz S nie trzeba zachowywać.\nDrugi aspekt przeświadczenia o braku wystarczającej liczby dostępnych rejestrów, jest związany z tym,\nże czasami rzeczywiście nie ma już miejsca (dostępnych rejestrów) do bezpośredniego zachowania wartości,\nktóra na końcu rozkazu musi być taka jak wcześniej. W takiej sytuacji należy zastanowić się, czy zamiast\nzachowywania danej wartość, nie dałoby się jej odtworzyć, np. poprzez wykonanie operacji odwrotnych/\nprzeciwnych, do tych które zmieniły tę potrzebną wartość (jeżeli np. od akumulatora odjęto wartość\nrejestru S, to, aby przywrócić wartość AK należy do niego dodać wartość rejestru S – oczywiście dotyczy\nto tylko sytuacji, w której wartość rejestru S nie uległa zmianie).\nKolejny powód przeświadczenia studentów o braku wystarczającej liczbie dostępnych rejestrów i braku\nmożliwości wykonania zadania, wynika z próby implementacji nieprawidłowego lub nieodpowiedniego\n(nieoptymalnego) algorytmu. W takiej sytuacji należy znaleźć inny sposób rozwiązania. Należy podkreślić,\nże wszystkie zadanie dawane do realizacji studentom są przetestowane i możliwe do realizacji na dostępnej\nliczbie rejestrów.\nNiektóre rozwiązania studentów są tak abstrakcyjne, nie tylko w tak wielu elementach nieoptymalne\nale posiadające całe zestawy błędów, że aż trudno je komentować. Czasami tak bardzo nie wiadomo ‘co\nstudent miał na myśli’ (czyli np. w miarę realizacji rozkazu, student wielokrotnie zmieniał koncepcję\nrozwiązania, lub też raczej nieskutecznie próbował ją znaleźć), tak bardzo brakuje całościowej, spójnej\n128\nR. Brzeski\nkoncepcji rozwiązania i zrozumienia poszczególnych jego elementów, że jedyną słuszną drogą jest ode-\nsłanie studenta do ponownego (a może pierwszego) zaznajomienia się z podstawowymi informacjami\ndotyczącymi projektowania rozkazu i tematyki Maszyny W.\nCzasami zdarzają się błędy drobne typu nieprawidłowa nazwa mikrosygnału, brak średnika w miejscu\nw którym chciano zakończyć takt, czy też błąd składniowy w instrukcji skoku warunkowego.\nInnej kategorii błędem, ale czasami występującym, jest sytuacja w której student zamiast samodzielnej\nrealizacji zadania, kopiuje je z innego źródła. Wynikiem może być pojawienie się u różnych studentów\ntych samych, często bardzo nietypowych błędnych rozwiązań. W ten sposób student nie daje sobie, ani\nmożliwości zrozumienia występujących uwarunkowań, ani nabycia praktycznych umiejętności w zakresie\nnie tylko implementacji ale i tworzenia prawidłowo działających, optymalnych algorytmów. Rozwiązaniem\nw takiej sytuacji może być przekazanie studentowi do realizacji nietypowego lub nowego rozkazu.\nJeżeli student opanował podstawy teoretyczne dotyczące tematu projektowania rozkazów, to czasami\ni tak pojawiają się błędy pojedyncze. Są one często na tyle typowe, na tyle często powtarzające się, że\nmożna zebrać je w zbiór błędów podstawowych i w ten sposób wskazać nie tylko te elementy na które\nwarto zwrócić uwagę, ale dać informację na temat prawidłowego sposobu rozwiązania/implementacji.\nTego typu błędy wraz z rozwiązaniami zostały przedstawione szczegółowo w rozdziale 3.\nOgólnie zagadnienie optymalizacji rozkazów, prawidłowego ich tworzenia, polega na tym, aby zaim-\nplementować prawidłowo działający rozkaz, w na tyle na ile to możliwe, najmniejszej liczbie taktów. Czyli\nparafrazując Alberta Einsteina, należy utworzyć rozkaz na tyle prosty na ile tylko jest to możliwe, ale nie\nprościej.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. Przykłady błędów przy implementacji rozkazów\nW tym rozdziale zostaną zaprezentowane konkretne przykłady, wraz z omówieniem typowych imple-\nmentacji nieprawidłowych oraz przedstawieniem rozwiązania prawidłowego.\n3.1. Błąd związany z brakiem prawidłowego zakończenia rozkazu.\nOmówienie zagadnienia:\nRozkaz poza realizacją zadania właściwego, musi także przygotować komputer do realizacji kolejnego\nrozkazu, który przy realizacji całego programu, będzie realizowany jako rozkaz następny. Aby to zrealizo-\nwać, w rejestrze A musi znaleźć się adres właśnie tego kolejnego rozkazu. Jeżeli rozkaz zgodnie ze swoja\ntreścią, nie wykonuje skoku do wyznaczonego miejsca w programie, to następny rozkaz do wykonania\njest kolejnym i wtedy wystarczy, aby w rejestrze A nalazła się wartość z rejestru licznika, który w pierw-\nszym takcie został zwiększony o jeden (mikrosygnałem il), czyli właśnie na adres następnego rozkazu po\nbieżącym. Zwykle realizowane jest to mikrosygnałami wyl wea.\nBłędny przykład 1.1 (Wartość rejestru akumulatora dodać do wartości rejestru AD, wynik doda-\nwania pozostawić w rejestrze akumulatora):\n// (AK) + (AD) →AK\nROZKAZ ZJ-J;\nczyt wys wei il;\nwyad sa weja dod weak; // błąd - brak zakończenia rozkazu\nPrawidłowe tworzenie rozkazów asemblerowych dla Maszyny W cz.1\n129\nPrawidłowe rozwiązanie 1.1:\n// (AK) + (AD) →AK\nROZKAZ ZJ-J;\nczyt wys wei il;\nwyad sa weja dod weak;\nwyl wea; // w rejestrze A musi znaleźć się wartość rejestru licznika\nJeżeli w rozkazie występuje instrukcja skoku warunkowego (‘JEżELI. . . ’) to odpowiednie zakończenie\nrozkazu musi znaleźć się w każdej ścieżce (instrukcji JEżELI).\nBłędny przykład 1.2 (Sprawdzić która z dwu wartości jest mniejsza i umieścić tę wartość w reje-\nstrze akumulatora. Początkowo pierwsza wartość jest w akumulatorze a druga w rejestrze AD):\n// min{(AK), (AD)} →AK\nROZKAZ ZJ-D;\nczyt wys wei il;\nwyad sa wes weja ode weak\nJEżELI z TO @wieksza GDY NIE @mniejsza;\n@wieksza wys weja dod weak wyl wea KONIEC; // w tej ścieżce jest prawidłowe zakończenie\n@mniejsza wys weja przep weak; // błąd - brak zakończenia w tej ścieżce\nPrawidłowe rozwiązanie 1.2:\n// min{(AK), (AD)} →AK\nROZKAZ ZJ-D;\nczyt wys wei il;\nwyad sa wes weja ode weak\nJEżELI z TO @wieksza GDY NIE @mniejsza;\n@wieksza wys weja dod weak wyl wea KONIEC;\n@mniejsza wys weja przep weak wyl wea; // obie ścieżki muszą odpowiednio kończyć rozkaz\nJeżeli jednak w bieżącym rozkazie jest do wykonania skok, to wtedy adres spod którego będzie czytany\nnastępny rozkaz, musi zostać umieszczony nie tylko w rejestrze A, ale także w rejestrze L, aby można\nkontynuować program od właśnie tego adresu. Przykładowo, jeżeli odpowiedni adres (zgodnie z treścią\nrozkazu do implementacji) miałby zostać pobrany z rejestru AD, to należałoby wykonać mikroinstrukcje\nwyad wel wea.\nBłędny przykład 1.3 (Wartość rejestru akumulatora dodać do wartości rejestru AD, a następnie\nwynik umieścić w rejestrze licznika – w ten sposób następuje skok w inne miejsce pamięci operacyjnej,\nczyli w inne miejsce umieszczonego w pamięci programu):\n// (AK) + (AD) →L\nROZKAZ ZJ-T;\nczyt wys wei il;\n130\nR. Brzeski\nwyad sa weja dod weak;\nwyak sa wel; // błąd - brak zakończenia rozkazu – wartość licznika nie została przesłana do A\nPrawidłowe rozwiązanie 1.3:\n// (AK) + (AD) →L\nROZKAZ ZJ-T;\nczyt wys wei il;\nwyad sa weja dod weak;\nwyak sa wel wea; // ta sama wartość musi się znaleźć w liczniku i rejestrze A\n3.2. Błąd związany z utratą wartości licznika w trakcie wykonywania rozkazu.\nOmówienie zagadnienia: Zawartość rejestru licznika (L), przede wszystkim z powodu kontekstu\nwykonywania całego programu, jest na tyle kluczowa, że zazwyczaj nie można jej utracić. Jedynie w sy-\ntuacji, gdy w ramach rozkazu wykonywany jest skok, wartość licznika jest odpowiednio nadpisywana.\nW innych sytuacjach jest odpowiednio inkrementowana, najczęściej o wartość 1, w porównaniu do war-\ntości jaka była tam w momencie rozpoczęcia wykonywania danego rozkazu (jeszcze przed wykonaniem\npierwszego taktu). Nie można więc jej całkowicie utracić, a jeżeli w trakcie wykonywania rozkazu zostanie\nchwilowo zmieniona, to należy odpowiednią wartość przywrócić.\nBłędny przykład 2.1 (Wartość rejestru AD zdekrementować o jeden i taki wynik umieścić w aku-\nmulatorze):\n// (AD) -1 →AK\nROZKAZ ZD-J;\nczyt wys wei il;\nwyad sa weja przep weak;\nwyl sa weja dod weak wea il; // błąd - utrata wartości licznika – nie został on nigdzie zapisany\nwyl sa weja ode weak;\nPrawidłowe rozwiązanie 2.1:\nDla tego rozkazu, przed zmianą wartości - zinkrementowaniem licznika o 1, jego wartość pierwotna\nzapisywana jest w rejestrze S [takt 3 - wyl sa wes] i jest przywracana [takt 5 - wys sa wel] po wykonaniu\ninnych operacji [takt 4]. W ten sposób ostatecznie wartość licznika nie ulega utracie, mimo wykonania\nzmiany jego wartości. Dla tego rozkazu warto dodatkowo zauważyć, że w ostatnim takcie wartość licznika\nnie jest wpisywana do rejestru A. Zostało to już zrealizowane w trzecim takcie mikrosygnałem wea.\nOczywiście ten sygnał wea zamiast w trzecim takcie, mógłby się znaleźć w ostatnim, ważne jest, aby po\nwykonaniu całego rozkazu, w rejestrze A znajdowała się ta sama wartość co w rejestrze L.\n// (AD) - 1 →AK\nROZKAZ ZD-J;\nczyt wys wei il;\nwyad sa weja przep weak;\nwyl sa weja dod weak wea wes il; // takt 3\nPrawidłowe tworzenie rozkazów asemblerowych dla Maszyny W cz.1\n131\nwyl sa weja ode weak; // takt 4\nwys sa wel; //takt 5\n3.3. Błąd związany z nieodpowiednim zakończeniem pierwszej ścieżki instruk-\ncji warunkowej ‘JEżELI’.\nOmówienie zagadnienia:\nPierwsza ścieżka instrukcji ‘JEżELI’ musi być odpowiednio zakończona. Jeżeli rozkaz ma się zakończyć\npo wykonaniu pierwszej ścieżki, to należy zakończyć go słowem kluczowym KONIEC (tak jak w rozdziale\n3.1. dla rozkazu ZJ-D [przykład 1.2]). Jeżeli natomiast chcielibyśmy, aby wykonywanie rozkazu było\nkontynuowane, to należy umieścić słowo kluczowe DALEJ wraz z nazwą etykiety dla drugiej ścieżki.\nBez odpowiedniego słowa kluczowego wystąpi błąd przy kompilacji rozkazu i student czasami traci dużo\nczasu na znalezienie przyczyny występowania tego błędu.\nBłędny przykład 3.1 (Jeżeli wartość w akumulatorze jest mniejsza od wartości rejestru AD, wtedy\npoczątkową wartość licznika należy zwiększyć o wartość 3, w przeciwnej sytuacji początkową wartość\nlicznika należy zwiększyć o jeden):\n// if (AK) < (AD) then (L)+3 →L else (L)+1 →L\nROZKAZ ZT-J;\nczyt wys wei il;\nwyad sa weja ode weak\nJEżELI z TO @wieksza GDY NIE @mniejsza;\n@wieksza il;\nil; // błąd - brak odpowiedniego słowa kluczowego\n@mniejsza wyl wea;\nPrawidłowe rozwiązanie 3.1:\n// if (AK) < (AD) then (L)+3 →L else (L)+1 →L\nROZKAZ ZT-J;\nczyt wys wei il;\nwyad sa weja ode weak\nJEżELI z TO @wieksza GDY NIE @mniejsza;\n@wieksza il;\nil DALEJ @mniejsza; // dodano słowo kluczowe DALEJ oraz nazwę etykiety @mniejsza\n@mniejsza wyl wea;\n3.4. Błąd związany z ponownym wpisaniem wartości do rejestru I.\nOmówienie zagadnienia:\nRejestr I ma specjalne przeznaczenie i w trakcie wykonywania rozkazu, poza pierwszym taktem, nie\nmożna do niego wpisywać jakichkolwiek wartości. Można jedynie odczytywać jego część AD. Jeżeli taki\nbłąd student zrobi w trakcie laboratorium, to otrzyma błąd już w trakcie kompilacji rozkazu. Jeżeli\nnatomiast ten błąd pojawi się w czasie egzaminu, to takie zadanie zazwyczaj oceniane jest na ocenę\nnegatywną, bez względu na pozostałą jego zawartość.\n132\nR. Brzeski\nBłędny przykład 4.1 (Do wartości akumulatora należy dodać wartość komórki pamięci, o adresie\nwskazywanym przez początkową wartość akumulatora. Wynik tego dodawania należy umieścić w rejestrze\nakumulatora):\n// (AK) + ((AK)) →AK\nROZKAZ ZC-J;\nczyt wys wei il; //pierwszy takt rozkazu\nwyak wei; // błąd - poza pierwszym taktem nie można używać mikrosygnału wei\nwyad wea;\nczyt wys weja weak dod wyl wea;\nPrawidłowe rozwiązanie 4.1:\n// (AK) + ((AK)) →AK\nROZKAZ ZC-J;\nczyt wys wei il;\nwyak sa wea; // wartość przesłana jest przez połączenie między magistralą danych a adresową\nczyt wys weja weak dod wyl wea;\n3.5. Błąd związany z umieszczaniem mikrosygnałów w nieodpowiednim takcie.\nOmówienie zagadnienia:\nUmieszczanie mikrosygnału w nieodpowiednim takcie może spowodować błędne działanie rozkazu,\nczęsto zupełnie inne niż student przewidywał. W danym takcie ciąg mikrosygnałów powinien stanowić\nzamknięty ciąg czynności. Najczęściej jest to przesłanie danej na magistralę i wpisanie tej danej z ma-\ngistrali do innego rejestru. Magistrala jest jedynie medium transmisyjnym i nie przechowuje wartości\numieszczonych tam danych pomiędzy taktami procesora. Nie można więc odczytywać w kolejnym takcie,\nwartości umieszczonej na magistrali w poprzednim takcie. Nie można także w jednym takcie umieszczać\nna tej samej magistrali danych z więcej niż jednego rejestru.\nBłędny przykład 5.1: (Podwójną początkową wartość akumulatora należy dodać do wartości reje-\nstru AD. Wynik tego dodawania należy umieścić w rejestrze akumulatora):\n// 2*(AK) + (AD) →AK\nROZKAZ ZP-J;\nczyt wys wei il;\nwyak weja dod weak wyad sa wes; // błąd - jednoczesne używanie tej samej magistrali\nwys weja dod weak wyl wea;\nBłędny przykład 5.2 (treść rozkazu jak w przykładzie 5.1):\n// 2*(AK) + (AD) →AK\nROZKAZ ZP-D;\nczyt wys wei il;\nwyak weja dod weak;\nwyad sa; // przesłanie wartości na magistralę danych bez wpisania jej do jakiegokolwiek rejestru\nPrawidłowe tworzenie rozkazów asemblerowych dla Maszyny W cz.1\n133\nweja dod weak wyl wea; // błąd - próba odczytu z pustej magistrali\nPrawidłowe rozwiązanie 5.1 i 5.2:\n// 2*(AK) + (AD) →AK\nROZKAZ ZP-J; // oraz ZP-D\nczyt wys wei il;\nwyak weja dod weak wyl wea; // na każdą z magistral wpisano tylko jedną wartość\nwyad sa weja dod weak; // po wysłaniu wartości na magistralę, w tym samy takcie jest pobierana\nWarto przy tym podkreślić, że w przedostatnim takcie rozkazu dopisano sygnały wyl wea, które po-\nwodują poprawne zakończenie tego rozkazu (a przy okazji została zoptymalizowana liczba taktów tego\nrozkazu). Zwykle tę parę sygnałów dopisujemy do ostatniego taktu. Jednak w tym przypadku ze wzglę-\ndu na fakt, że w ostatnim takcie używane są obie magistrale, nie jest to możliwe. Trzeba więc byłoby\ndopisać dodatkowy takt wraz tymi sygnałami (wyl wea), wydłużając tym samym liczbę taktów. Możemy\njednak zauważyć, że w przedostatnim takcie magistrala adresowa nie była używana, więc tę parę sygna-\nłów (przygotowującą rejestr adresowy do poprawnego rozpoczęcia kolejnego rozkazu) można było dopisać\nwcześniej.\nBłędny przykład 5.3 (Jeżeli wartość akumulatorze jest mniejsza od wartości rejestru AD wtedy\npoczątkową wartość licznika należy zwiększyć o wartość 3 w przeciwnej sytuacji początkową wartość licz-\nnika należy zwiększyć o jeden):\n// if (AK) < (AD) then (L)+3 →L else (L)+1 →L\nROZKAZ ZP-T;\nczyt wys wei il;\nwyad sa weja ode weak\nJEżELI z TO @wieksza GDY NIE @mniejsza;\n@wieksza il il DALEJ @mniejsza; // błąd - nie można w tym samym takcie inkrementować\n// licznika więcej niż jeden raz\n@mniejsza il wyl wea; // błąd opisany poniżej\nW ostatnim takcie, inkrementacja wartości licznika (il) zostanie zrealizowana dopiero po wysłaniu\nwartości nieinkrementowanej (do A poprzez wyl wea). W tym konkretnym przykładzie, student poka-\nzuje jak wielu elementów jeszcze nie rozumie. Zwiększenie licznika w ten sposób najprawdopodobniej\nspowoduje błędne wyznaczenie kolejnego rozkazu do wykonania, w czasie realizacji następnego rozkazu\npo bieżącym. Jednocześnie takie użycie inkrementacji licznika, w zależności od treści zadania, może nie\nrealizować wymaganej w bieżącym rozkazie czynności.\nPrawidłowe rozwiązanie 5.3:\n// if (AK) < (AD) then (L) +3 →L else (L) +1 →L\nROZKAZ ZP-T;\nczyt wys wei il;\nwyad sa weja ode weak\n134\nR. Brzeski\nJEżELI z TO @wieksza GDY NIE @mniejsza;\n@wieksza il; // po wykonaniu inkrementacji następuje zakończenie taktu\nil DALEJ @mniejsza; // kolejna inkrementacja L jest wykonywana niezależnie od poprzedniej\n@mniejsza wyl wea; // w tym takcie przesłana do A wartość licznika nie zostaje już zmieniona\n3.6. Błąd związany z nieprawdziwym założeniem co do wartości danego reje-\nstru.\nOmówienie zagadnienia:\nNie można robić wstępnych (nieprawdziwych) założeń, co do wartości danego rejestru np., że za-\nwartość rejestru licznika jest równa jeden. Niestety studenci często robią takie nieprawidłowe założenia.\nW kontekście licznika, prawdopodobnie związane jest to z brakiem świadomości szerszego kontekstu wyko-\nrzystania tworzonego rozkazu. Rozkazy asemblerowe są tworzone po to, aby tworzyć z nich całe programy.\nPojedynczy rozkaz, jeżeli zostanie umieszczony w programie jako pierwszy, to w czasie wykonania jego\npierwszego taktu, inkrementuje on licznik do wartości 1. Wynika to z tego, że adresacja pamięci rozpo-\nczyna się od wartości 0 i to od niej Maszyna W zaczyna wykonywać cały program. Kolejne rozkazy będą\nponownie zmieniać wartość licznika, zazwyczaj na wartość inną niż 1. Dlatego jedynie rozkaz umieszczo-\nny w programie jako pierwszy, uzyska wartość w liczniku równą 1 i tylko wtedy rozkaz zakładający taką\nwartość w liczniku, mógłby działać prawidłowo. Celem utworzenia rozkazu jest jednak, aby działał on w\ndowolnym miejscu programu. Dlatego nie można robić założeń co do jakichkolwiek konkretnych wartości\nw poszczególnych rejestrach. Przyjmujemy zatem, że w rejestrach są jakieś nieznane wartości, na których\nzgodnie z treścią danego rozkazu, wykonuje on odpowiednie operacje.\nBłędny przykład 6.1 (Wartość rejestru AD zdekrementować o jeden i taki wynik umieścić w aku-\nmulatorze):\n// (AD) - 1 →AK\nROZKAZ ZS-J;\nczyt wys wei il;\nwyad sa weja przep weak;\nwyl sa weja ode weak wea; // błąd - nieuprawnione założenie o zawartej w liczniku wartości 1\nPrawidłowe rozwiązanie 6.1:\n// (AD) - 1 →AK\nROZKAZ ZS-J;\nczyt wys wei il;\nwyad sa weja przep weak;\nwyl sa weja dod weak wea wes il; // takt 3\nwyl sa weja ode weak; // takt 4\nwys sa wel; //takt 5\nTym razem bez względu na pierwotną wartość licznika, dodając tę wartość do akumulatora [takt 3 –\nwyl sa weja dod weak] i zwiększając jej wartość o jeden [takt 3 – il], a następnie odejmując od akumulatora\ntę zwiększoną wartość licznika [takt 4 – wyl sa weja ode weak] w efekcie odejmuje się od akumulatora\npożądaną wartość 1.\nPrawidłowe tworzenie rozkazów asemblerowych dla Maszyny W cz.1\n135",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. Wnioski końcowe\nW rozdziale 1 umieszczono wytyczne dotyczące przygotowania studenta do zajęć laboratoryjnych.\nW rozdziale 2 omówiono ogólne zagadnienia dotyczące rozwiązywania potencjalnych problemów, wystę-\npujących przy implementacji rozkazów asemblerowych dla Maszyny W. W rozdziale 3 przedstawiono\nprzykłady podstawowych błędów popełnianych przez studentów wraz z rozwiązaniami prawidłowymi. Na\ntej podstawie można utworzyć zbiór błędów typowych:",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. Utrata wartości licznika w trakcie wykonywania rozkazu - wartość licznika jest kluczowa, nie można\njej ’tak po prostu’ utracić.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "3. Nieodpowiednie zakończenie pierwszej ścieżki instrukcji ‘JEżELI’. Należy użyć predefiniowanego\nsłowa DALEJ. . . lub KONIEC.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. Nadpisywanie zawartości rejestru I - ma on specjalne przeznaczenie i w trakcie wykonywania roz-\nkazu, poza pierwszym taktem, nie można do niego wpisywać jakichkolwiek wartości.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "5. Umieszczanie mikrosygnałów w nieodpowiednim takcie. Aby pobrać wartość z magistrali, w tym\nsamym takcie należy ją tam umieścić. W danym takcie na magistralę można przesłać wartość tylko\nz jednego rejestru.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "6. Nieprawdziwe, nieuprawnione wstępne założenia co do wartości danego rejestru np., że licznik za-\nwiera wartość 1 - nie można robić takich założeń.\nArtykuł ten stanowi, szczególnie dla studentów, dobre narzędzie do sprawdzenia przygotowania wstęp-\nnego do zajęć - na podstawie spisu wiedzy teoretycznej, potrzebnej do realizacji zadania tworzenia roz-\nkazów. Artykuł ten jest także zbiorem materiału nie tylko pomocnego przy realizacji otrzymanych zadań\ni rozwiązywaniu potencjalnych problemów przez studentów, ale także, przy odpowiednim opanowaniu\nzawartych tu wskazówek, pozwala tych problemów uniknąć.\nLiteratura",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "1. M. Chłopek, R. Tutajewicz, Wykłady z Podstaw Informatyki profesora Stefana Węgrzyna, Skrypt\nuczelniany Politechniki Śląskiej nr 2062. Wydawnictwo Politechniki Śląskiej, Gliwice, 1997.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "2. K. Grochla, G. Hryń, S. Iwaszenko, P. Kasprzyk, J. Kubica, M. Widera, T. Wróbel, Wykłady z podstaw\nInformatyki profesora Stefana Węgrzyna, Skrypt uczelniany Politechniki Śląskiej nr 2321. Wydawnic-\ntwo Politechniki Śląskiej, Gliwice, 2003.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "4. A. Momot, Projektowanie rozkazów dla maszyny W - konspekt ćwiczeń laboratoryjnych, MINUT 2020\n(2), s. 1-11.",
    "source": "rozkazy cz1 v2.pdf",
    "tags": [],
    "type": "unknown"
  },
  {
    "content": "// obliczanie NWD( a, b ) wg algorytmu Euklidesa\npocz:  pob a\net1:   ode b\n       soz jest\n       som zmB\n       ład a\n       sob et1\nzmB:   pob b\n       ode a\n       ład b\n       sob pocz\njest:  pob a\n       stp        \na:     rst 32\nb:     rst 24",
    "source": "1.1.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// Obliczanie liczby wystąpień określonej wartości Val w N-elementowej tablicy bajtów Tab\nstart:     pob N\n           ode jeden\n           som koniec\n           ład N\nrozkaz:    pob Tab\n           ode Val\n           soz Inc\nDalej:     pob rozkaz\n           dod jeden\n           ład rozkaz\n           sob start\nkoniec:    pob ile\n           stp\nInc:       pob ile\n           dod jeden\n           ład ile\n           sob Dalej\nVal:       rst 3\nile:       rst 0\njeden:     rst 1\nN:         rst 5\nTab:       rst 1\n           rst 2\n           rst 3\n           rst 6\n           rst 3\n           rst 3",
    "source": "1.2.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// Obliczanie silni z n z wykorzystaniem podprogramu realizującego mnożenie liczb\nstart:  pob n\n        ode dwa\n        som jest\n        pob n\n        dns\n        pob s\n        dns\n        sdp mnoz\n        ład s\n        pob n \n        ode jeden\n        ład n\n        sob start\njest:   pob s\n        stp\nn:      rst 1\t// liczba której silnię obliczamy\ns:      rst 1\ndwa:    rst 2\n// mnożenie liczb całkowitych x i y\n// liczby przekazane przez stos, wynik zwracany w akumulatorze\nmnoz:   pzs\n        ład ślad\n        pzs\n        ład y\n        som neg\n        pzs\n        ład x\n        sob next\nneg:    pob zero \t// jeśli mnożnik ujemny - zamień znaki argumentów\n        ode y\n        ład y\n        pzs\n        ład x\n        pob zero\n        ode x\n        ład x         \nnext:   pob ślad\t// ślad od razu na stos aby potem nie zapomnieć\n        dns\n        pob zero\n        ład wynik\npetla:  pob y\t// dekrementacja mnożnika\n        ode jeden\n        ład y\n        som ready\t// gdy mnożnik ujemny - koniec\n        pob wynik\t// mnożenie przez wielokrotne dodawanie mnożnej x\n        dod x\n        ład wynik\n        sob petla\nready:  pob wynik\n        pwr\nślad:   rpa\t// miejsce na ślad\nx:      rpa\t\t// mnożna\ny:      rpa\t\t// mnożnik\nwynik:  rpa\t// wynik musi być zainicjowany w kodzie wartością 0\nzero:   rst 0\njeden:  rst 1",
    "source": "1.3.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// Obliczanie NWW dwu liczb naturalnych a i b\n        pob a     // kopiowanie a do a1 i b do b1\n        ład a1\n        pob b\np1:     ład b1\npętla:  ode a1\n        soz jest  // jeśli a1 = b1 - koniec obliczeń\n        som zmienb // jeśli b1 < a1 należy zwiększyć b1\n        pob a1     // w przeciwnym razie zwiększyć a1 dodając oryginalne a\n        dod a\n        ład a1\n        pob b1     // przed kolejnym testem równości w AK ma być b1\n        sob pętla\nzmienb: pob b1     // zwiększyć b1 dodając oryginalne b\n        dod b\n        sob p1     // i znów testować równość\njest:   pob a1     // wynik zostawia w AK\n        stp\na:      rst 6      // argumenty NWW\nb:      rst 8\na1:     rpa        // zmienne przechowujące skopiowane dane\nb1:     rpa",
    "source": "2.1.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// „Odwracanie” tablicy o znanej długości (ABC › CBA )\nstart:  pob zero      // inicjalizacja indeksów i i j\n        ład i\n        pob n\n        ode jeden\n        ład j\ndalej:  pob pobtab    // ustalenie właściwej postaci\n        dod i         // rozkazów pob i ład\n        ład pobti\n        pob pobtab\n        dod j\n        ład pobtj\n        pob ładtab\n        dod i\n        ład ładti\n        pob ładtab\n        dod j\n        ład ładtj\npobti:  rpa           // tu zaczyna się właściwa zamiana\n        ład tmp       // konieczne użycie zmiennej tymczasowej\npobtj:  rpa           // Tab[ i ] = Tab[ j ]\nładti:  rpa\n        pob tmp       // Tab[ j ] = tmp\nładtj:  rpa\n        pob i         // przesunięcie indeksów\n        dod jeden     // i o jeden w dół\n        ład i\n        pob j         // j o jeden w górę\n        ode jeden\n        ład j       \n        pob i         // pętla wykonywana dalej jeśli\n        ode j         // i < j\n        som dalej     // w przeciwnym razie koniec\n        stp            \ni:      rst 0\nj:      rpa\njeden:  rst 1          // przydatne stałe\nzero:   rst 0\ntmp:    rpa            // tymczasowa zmienna\npobtab: pob tab        // kody rozkazów POB tab i ŁAD tab\nładtab: ład tab\nn:      rst 6          // długość tablicy\ntab:    rst 6          // i wreszcie sama tablica\n        rst 5\n        rst 4\n        rst 3\n        rst 2\n        rst 1\n        rst 8\n        rst 7",
    "source": "2.2.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// Potgowanie a^b z wykorzystaniem podprogramu mnoenia\nstart:  pob b\t// jeli wykadnik rwny 0 - nic nie trzeba robi\n        ode jeden\n        som jest\n        ad b\t// w kadym przebiegu ptli wykadnik jest zmniejszany\n        pob a\t// mnoenie podstawy przez dotychczasowy wynik\n        dns\n        pob s\n        dns\n        sdp mnoz\n        ad s\n        sob start\t// powtarzamy a wykadnik rwny 0\njest:   pob s\t// wynik znaleziony\n        stp\na:      rst 5\t// podstawa\nb:      rst 3\t// wykadnik\ns:      rst 1\t// wynik zainicjowany wartoci 1\n// mnoenie liczb cakowitych x i y\n// liczby przekazane przez stos, wynik zwracany w akumulatorze\nmnoz:   pzs\n        ad lad\n        pzs\n        ad y\n        som neg\n        pzs\n        ad x\n        sob next\nneg:    pob zero \t// jeli mnonik ujemny - zamie znaki argumentw\n        ode y\n        ad y\n        pzs\n        ad x\n        pob zero\n        ode x\n        ad x         \nnext:   pob lad\t// lad od razu na stos aby potem nie zapomnie\n        dns\n        pob zero\n        ad wynik\npetla:  pob y\t// dekrementacja mnonika\n        ode jeden\n        ad y\n        som ready\t// gdy mnonik ujemny - koniec\n        pob wynik\t// mnoenie przez wielokrotne dodawanie mnonej x\n        dod x\n        ad wynik\n        sob petla\nready:  pob wynik\n        pwr\nlad:   rpa\t// miejsce na lad\nx:      rpa\t\t// mnona\ny:      rpa\t\t// mnonik\nwynik:  rpa\t// wynik musi by zainicjowany w kodzie wartoci 0\nzero:   rst 0\njeden:  rst 1",
    "source": "2.3.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// Obliczanie iloczynu dwu liczb naturalnych x i y\npetla:  pob y\t// dekrementacja mnożnika\n        ode jeden\n        ład y\n        som ready\t// gdy mnożnik ujemny - koniec\n        pob wynik\t// mnożenie przez wielokrotne dodawanie mnożnej x\n        dod x\n        ład wynik\n        sob petla\nready:  pob wynik\n        stp\nx:      rst 3\t\t// mnożna\ny:      rst 2\t\t// mnożnik\nwynik:  rst 0\t// wynik musi być zainicjowany w kodzie wartością 0\njeden:  rst 1",
    "source": "3.1.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// „Odwracanie” tablicy o znanej długości (ABC › CBA )\nstart:  pob zero      // inicjalizacja indeksów i i j\n        ład i\n        pob n\n        ode jeden\n        ład j\ndalej:  pob pobtab    // ustalenie właściwej postaci\n        dod i         // rozkazów pob i ład\n        ład pobti\n        pob pobtab\n        dod j\n        ład pobtj\n        pob ładtab\n        dod i\n        ład ładti\n        pob ładtab\n        dod j\n        ład ładtj\npobti:  rpa           // tu zaczyna się właściwa zamiana\n        ład tmp       // konieczne użycie zmiennej tymczasowej\npobtj:  rpa           // Tab[ i ] = Tab[ j ]\nładti:  rpa\n        pob tmp       // Tab[ j ] = tmp\nładtj:  rpa\n        pob i         // przesunięcie indeksów\n        dod jeden     // i o jeden w dół\n        ład i\n        pob j         // j o jeden w górę\n        ode jeden\n        ład j       \n        pob i         // pętla wykonywana dalej jeśli\n        ode j         // i < j\n        som dalej     // w przeciwnym razie koniec\n        stp            \ni:      rst 0\nj:      rpa\njeden:  rst 1          // przydatne stałe\nzero:   rst 0\ntmp:    rpa            // tymczasowa zmienna\npobtab: pob tab        // kody rozkazów POB tab i ŁAD tab\nładtab: ład tab\nn:      rst 6          // długość tablicy\ntab:    rst 6          // i wreszcie sama tablica\n        rst 5\n        rst 4\n        rst 3\n        rst 2\n        rst 1\n        rst 8\n        rst 7",
    "source": "3.2.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// Obliczanie wartoci wyznacznika macierzy 2 x 2 przy wykorzystaniu podprogramu mnoenia\n// a11 * a22 - a12 * a21\nstart:  pob a12\t// a12 * a21\n        dns\n        pob a21\n        dns\n        sdp mnoz\n        ad s\n        pob a11\t// a11 * a22\n        dns\n        pob a22\n        dns\n        sdp mnoz\n        ode s\t// a11 * a22 - a12 * a21\n        ad s\n        stp        \na11:    rst 5\t// elementy macierzy a\na12:    rst 4\na21:    rst 1\na22:    rst 2\ns:      rst 0\t// zmienna pomocnicza\n// mnoenie liczb cakowitych x i y\n// liczby przekazane przez stos, wynik zwracany w akumulatorze\nmnoz:   pzs\n        ad lad\n        pzs\n        ad y\n        som neg\n        pzs\n        ad x\n        sob next\nneg:    pob zero \t// jeli mnonik ujemny - zamie znaki argumentw\n        ode y\n        ad y\n        pzs\n        ad x\n        pob zero\n        ode x\n        ad x         \nnext:   pob lad\t// lad od razu na stos aby potem nie zapomnie\n        dns\n        pob zero\n        ad wynik\npetla:  pob y\t// dekrementacja mnonika\n        ode jeden\n        ad y\n        som ready\t// gdy mnonik ujemny - koniec\n        pob wynik\t// mnoenie przez wielokrotne dodawanie mnonej x\n        dod x\n        ad wynik\n        sob petla\nready:  pob wynik\n        pwr\nlad:   rpa\t// miejsce na lad\nx:      rpa\t\t// mnona\ny:      rpa\t\t// mnonik\nwynik:  rpa\t// wynik musi by zainicjowany w kodzie wartoci 0\nzero:   rst 0\njeden:  rst 1",
    "source": "3.3.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// Wyszukiwanie największej liczby w tablicy o znanej długości\nstart:  pob jeden      // indeks i ustawiony na 1\n        ład i          // będziemy startować od drugiego elementu\n        pob tab        // max = tab[ 0 ]\n        ład max\n        pob n          // ale, ale, może tablica 1-elementowa\n        ode i\n        soz gotowe\ndalej:  pob pobtab     // wyznacza właściwą postać rozkazu\n        dod i         \n        ład pobti      // i zpisuje w odpowiednie miejsce\npobti:  rpa            // tmp = Tab[ i ]\n        ład tmp\n        pob max        // czy nowy element nie jest większy od max\n        ode tmp\n        som nowe       // jeśli tak to czas zmienić max\ninc:    pob i          // inkrementacja i\n        dod jeden\n        ład i\n        ode n          // oraz sprawdzenie, czy to nie koniec\n        soz gotowe\n        sob dalej\nnowe:   pob tmp        // max = tmp\n        ład max\n        sob inc\ngotowe: pob max        // pobranie wyniku do AK\n        stp\ntmp:    rpa\ni:      rpa            // indeks aktualnego elementu\njeden:  rst 1          // przydatne stałe\nmax:    rpa\npobtab: pob tab        // kod rozkazy POB tab\nn:      rst 7          // długość tablicy\ntab:    rst 6          // i wreszcie sama tablica\n        rst 5\n        rst 4\n        rst 3\n        rst 2\n        rst 1\n        rst 8\n        rst 7",
    "source": "4.2.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// Sprawdzanie czy dana liczba n jest liczb pierwsz z wykorzystaniem podprogramu reszty z dzielenia\n// zwraca -1 gdy liczba pierwsza\n// 0 - jeli nie\n         pob d\t// dopki d < n powtarzaj\nstart:  ode n\n        som test\t// d >= n zatem liczba pierwsza\n        pob minus1\n        stp\ntest:   pob n\t// oblicza n % d\n        dns\n        pob d\n        dns\n        sdp mod\n        soz nie\t// jeli n % d == 0 => liczba n nie jest pierwsza\n        pob d\t// jeli n % d > 0 sprawdzaj dla kolejnego dzielnika d\n        dod jeden\n        ad d\n        sob start\nnie:    stp        \nd:      rst 2\t// sprawdzanie zaczynamy od podzielnika 2\nn:      rst 7\t// sprawdzana liczba\njeden:  rst 1\n// obliczanie reszty z dzielenia liczb naturalnych x % y\n// liczby przekazane przez stos, wynik zwracany w akumulatorze\n// gdy y < 1 zwraca -1\n// gdy x < 0 zwraca -1\nmod:    pzs\n        ad lad\n        pzs\n        ad y\n        som negy\n        soz negy\n        pzs\n        som negx\nznowu:  ode y\t// powtarza odejmowanie a w akumulatorze bdzie liczba ujemna\n        som jest\n        sob znowu\njest:   dod y\t// aby znale reszt trzeba doda dzielnik\n        ad x\t// reszta znaleziona\n        pob lad\t// nie wolno zapomnie o ladzie\n        dns\n        pob x\n        pwr\nnegy:   pzs   \t// koniecznie pobierz x ze stosu\nnegx:   pob lad\t// teraz zapisz tam lad\n        dns\n        pob minus1\t// wynikiem jest -1\n        pwr\nlad:   rpa\nx:      rpa\ny:      rpa\nminus1: rst -1",
    "source": "4.3.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "// Obliczanie liczby wystąpień określonej wartości w N-elementowej tablicy bajtów\nstart:  pob zero       // indeks i ustawiony na 0\n        ład i          // \ndalej:  pob pobtab     // wyznacza właściwą postać rozkazu\n        dod i         \n        ład pobti      // i zpisuje w odpowiednie miejsce\npobti:  rpa            // Tab[ i ]\n        ode wz\n        soz zwiększ\ninc:    pob i          // inkrementacja i\n        dod jeden\n        ład i\n        ode n          // oraz sprawdzenie, czy to nie koniec\n        soz gotowe\n        sob dalej\nzwiększ: pob ile       // kolejny element znaleziony \n        dod jeden\n        ład ile\n        sob inc\ngotowe: pob ile        // pobranie wyniku do AK\n        stp\ntmp:    rpa\ni:      rpa            // indeks aktualnego elementu\njeden:  rst 1          // przydatne stałe\nzero:   rst 0\nwz:     rst 3\nile:    rst 0\npobtab: pob tab        // kod rozkazy POB tab\nn:      rst 7          // długość tablicy\ntab:    rst 6          // i wreszcie sama tablica\n        rst 3\n        rst 4\n        rst 3\n        rst 2\n        rst 1\n        rst 3\n        rst 3",
    "source": "6.2.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "//dodawanie wszystkich elementów w tablicy\nloop:\nPOB size\nODE one\nSOM end\nLAD size\n\nPOB sum\ninst: DOD array\nLAD sum\n\n//zwiększanie indeksu tablicy\nPOB inst\nDOD one\nLAD inst\n\nSOB loop\n\nend:  POB sum\nSTP\n\narray: RST 1\n       RST 3\n       RST 4\n       RST 3\nsize: RST 4\none: RST 1\nsum: RST 0",
    "source": "Adding_el_array.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "//Zdekrementuj wszystkie elementy w tablicy\n//liczba elementów w tablicy jest określona w osobnej zmiennej\n//ROZMIAR: RST 3 //liczba elementów: 3\n//TABLICA: RST 1\n//RST 2\n//RST 3\n\n\nTABLE_SIZE: POB     SIZE\n            ODE     ONE\n            SOM     END\n            LAD     SIZE\n\nSUB: POB     ARRAY\n     ODE     ONE\n\nWHERE: LAD     ARRAY\n\nL1: POB     SUB\n    DOD     ONE\n    LAD     SUB\n    POB     WHERE\n    DOD     ONE\n    LAD     WHERE\n    SOB     TABLE_SIZE\n           \nEND: STP\n\nONE:    RST 1\nSIZE:   RST 2\nARRAY:  RST 1\n        RST 2\n        RST 3\n        RST 4\n        RST 5\n        RST 6",
    "source": "Decrement.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "//zdekrementuj wszystkie elementy w tablicy\nloop:\nPOB size\nODE one\nSOM end\nLAD SIZE\n\ninst1: POB ARRAY\nODE DecrementBy\ninst2: LAD ARRAY\n\nPOB inst1\nDOD one\nLAD inst1\n\nPOB inst2\nDOD one\nLAD inst2\n\nSOB loop \n\nend: \nSTP\n\n\nSIZE: RST 8  //number of elements: 3 | liczba elementów: 3\nARRAY: RST 8\nRST 10\nRST 3\nRST 1\nRST 2\nRST 3\nRST 4\nRST 5\n\nDecrementBy: RST 2\none: RST 1",
    "source": "DecrementAllElements.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "//Oblicz potęgowanie dwóch liczb naturalnych\n\nPOB Final\nDOD Num1\nLAD Final\n\nPOB Num2\nSOZ end_exp_one\n\nPOB Num1\nSOZ end_exp_zero\n\nMain_exp:\nPOB Num2\nODE one\nSOZ end_exp\nLAD Num2\n\n//Poniższy program mnoży dwie liczby\nMain_product:\nPOB Num1\nLAD N1\nPOB Final\nLAD N2\n//Sprawdzanie licznika\nPOB N2\nSOZ end\nSOM Negative\nLAD Counter\n\n//Sprawdzanie wyniku mnożenia\nPOB N1\nSOZ end\nLAD Product\nLAD First_Prdct\n\nloop:\nPOB Counter\nODE One\nLAD Counter\nSOZ end\n\nPOB Product\nDOD First_Prdct\nLAD Product\n\nSOB loop\n\n//Jeżeli licznik jest ujemny, zmień wartości licznika i wyniku mnożenia\nNegative: \nLAD Product\nLAD First_Prdct\nPOB N1\nSOZ end\nLAD Counter\n\nSOB loop\n\nend: \nPOB Product\nLAD Final\nSOB Main_exp\n//Koniec mnożenia\n\nend_exp:\nPOB Final\nSTP\n\nend_exp_one:\nPOB one\nSTP\n\nend_exp_zero:\nPOB zero\nSTP\n\n\nOne: RST 1\nN1: RST 0\nN2: RST 0\nFirst_Prdct: RPA\nCounter: RPA\nProduct: RPA\n//Dla Mnożenia\n\nNum1: RST 5\nNum2: RST 0\nFinal: RST 0\nzero: RST 0",
    "source": "Exp2N.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "//Oblicz iloczyn dwóch liczb naturalnych\n\nLOOP:\nPOB     PRODUCT\nDOD     A\nLAD     PRODUCT\nPOB     B\nODE     ONE\nSOZ     END\nLAD     B\nSOB     LOOP\n\nEND:\nPOB     PRODUCT\nSTP\n\nONE:    RST 1\nA:      RST 6\nB:      RST 3\nPRODUCT:   RST 0",
    "source": "Product.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "//Iloczyn 2 liczb naturalnych\n\nMain:\n//Ustalenie wartości licznika\nPOB N2\nSOZ end\nSOM Negative\nLAD Counter\n\n//Ustalenie wartości iloczynu\nPOB N1\nSOZ end\nLAD Product\nLAD First_Prdct\n\nloop:\nPOB Counter\nODE One\nLAD Counter\nSOZ end\n\nPOB Product\nDOD First_Prdct\nLAD Product\n\nSOB loop\n\n//Jeśli licznik jest ujemny, zmień wartości licznika i iloczynu\nNegative: \nLAD Product\nLAD First_Prdct\nPOB N1\nSOZ end\nLAD Counter\n\nSOB loop\n\nend: \nPOB Product\nSTP\n\nOne: RST 1\nN1: RST 4\nN2: RST 10\nFirst_Prdct: RPA\nCounter: RPA\nProduct: RPA",
    "source": "Product_2N.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "//Przeszukaj tablicę w poszukiwaniu wartości określonej w oddzielnej zmiennej i zapisz indeks jej pierwszego wystąpienia.\n//Użyj dodatkowej zmiennej do oznaczenia końca tablicy.\n\nNEXT: POB ARRAY\n       SOM END_OF_ARRAY\n       ODE SEARCHED\n       SOZ FOUND      \nL1:     \n      POB INDEX\n      DOD ONE\n      LAD INDEX\n        POB NEXT\n        DOD ONE\n        LAD NEXT\n        SOB NEXT  \n\n      \nFOUND:  STP\n\nEND_OF_ARRAY: STP \n\nSEARCHED: RST 7\nINDEX: RST 1\nONE: RST 1 \nCharValue: RST -1  // dodatkowa zmienna\nARRAY: RST 1\nRST 2\nRST 2\nRST 7\nRST -1  // koniec tablicy",
    "source": "Search.prg",
    "tags": [],
    "type": "prg"
  },
  {
    "content": "//Przeszukaj tablicę w poszukiwaniu wartości określonej w oddzielnej zmiennej i policz liczbę wystąpień.\n\nloop:\ninst: POB array\nODE CharValue\nSOZ end\nDOD CharValue\n\n//Sprawdzenie wartości w tablicy\nODE LookedForValue\nSOZ OccurenceFound\nSOB continue\n\nOccurenceFound: POB occurences\n                DOD one\n                LAD occurences\n                \ncontinue: POB inst\n          DOD one\n          LAD inst\n          SOB loop\n          \nend: POB occurences\n     STP\n\nCharValue: RST 0\nARRAY: RST -3\n       RST 2\n       RST 3\n       RST 5\n       RST 6\n       RST 5\n       RST 10\n       RST -3\n       RST 0 \nLookedForValue: RST -3\noccurences: RST 0\none: RST 1",
    "source": "Search_value.prg",
    "tags": [],
    "type": "prg"
  }
]